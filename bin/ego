#!/usr/bin/env bash

set -o nounset
set -o errexit

# Naming convention:
# - public_function: these can be executed via "ego public_function param1 [param2] ..."
# - _private_function: these cannot be called via the CLI
#
# Main logic:
# These are probably the more useful abstractions, since they can be used to quickly set-up a new host and execute a desired
# flow to either confirm that the E2E tests can be run against a custom build, or to simply provision a custom environment.
# - ops_manager_install_version: Installs the specified Ops Manager Version, then starts it
#                                on Linux, SSL can also be configured
# - ops_manager_install_from_link: Download and install the given Ops Manager package

# - ops_manager_clean: Reset the environment to resemble a fresh Ops Manager install (delete AppDb and Blockstore data dir)
# - ops_manager_start_from_tgz: Given an Ops Manager tgz, extract the files and start the service with the current user account
#
# Other features:
# - run: executes the specified command on a remote host via SSH and pipes all output to stdout
# - run-background: similar to run, but launches a background process via SSH, then disconnects
# - tail: follow logs generated by the 'ego run-background' command
# - system_info: print information about the current running system
# - resolve_system_dependencies: install all required system dependencies required to run Ops Manager
#                               (package and source-code) (Linux-only)
# - _determine_architecture: detect running distribution and stop execution if not supported
# - get_host_ip/aws_get_local_ip/aws_get_public_ip/gcp_get_public_ip: retrieve the running host's private/public IP (AWS/GCP
# - service_command: start/stop/restart services (automatically choosing SystemD, SysV, and init.d scripts)
# - is_local_port_open: detect if a specified port is open
# - wait_for_open_local_port/wait_for_closed_local_port: wait until the specified port is open/closed on 127.0.0.1
# - wait_for_open_port/wait_for_closed_port: wait until the port is open/closed on the specified host
# - wait_for_mms_service_to_exit: wait until the mms service reaches an exit state
# - replace_property_in_file: replace (or define) a key=value in a property file
# - _install_test_dependencies/install_*: install various dependencies: chrome_driver, chrome, nodejs, ant, jdk, docker
# - download_mongodb/start_mongodb: download MongoDB, install it, and start or stop it (all platforms)
# - start_ops_manager/stop_ops_manager/restart_ops_manager: start/stop/restart ops manager (all platforms)
# - network_access_restrict: restrict access to/from the current host (Linux-only, iptables) - useful for Local Mode testing
# - configure_proxy: configure an HTTP proxy (Linux-only, squid) - useful for Ops Manager HTTP proxy configuration testing
# - ssl_generate_server_certificate: generate Root CA and SSL certificates for a specified host - useful for Ops Manager with SSL testing
# - ops_manager_configure_ssl: configure Ops Manager to start with SSL-enabled (Linux only)
#
# NOTE: Not all actions can be performed in all systems, due to various incompatibilities.
#       Wherever this is the case, the script will alert you and in some cases stop execution altogether.
# NOTE 2: If you want to enable explicit debugging, you can do so by: `export EGO_DEBUG=1` before running `ego`
#

readonly DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
readonly CWD="$(dirname "$(dirname "$(dirname "$(readlink "$0")")")")" # ego is installed in CWD/.ego/bin
readonly SCRIPT=$(basename "${BASH_SOURCE[0]}")
readonly NON_ROOT_FUNCTIONS="_set_mongod_vars aws_get_local_ip aws_get_public_ip gcp_get_public_ip get_host_ip get_om_port get_om_scheme get_public_ip is_local_port_open run run-background seed ssh system_info tail wait_for_closed_local_port wait_for_open_local_port wait_for_open_port"

# Other settings
declare -a curl_opts
curl_opts[0]="--silent"
curl_opts[1]="--show-error"
curl_opts[2]="--fail"
curl_opts[3]="--location"
curl_opts[4]="--retry"
curl_opts[5]="3"
curl_opts[6]="--create-dirs"
readonly curl_opts
declare -a ssh_opts
ssh_opts[0]="-o"
ssh_opts[1]="UserKnownHostsFile=/dev/null"
ssh_opts[2]="-o"
ssh_opts[3]="StrictHostKeyChecking=no"
ssh_opts[4]="-q"
ssh_opts[5]="-o"
ssh_opts[6]="ConnectTimeout=30"
ssh_opts[7]="-o"
ssh_opts[8]="TCPKeepAlive=yes"
ssh_opts[9]="-o"
ssh_opts[10]="ServerAliveInterval=15"
ssh_opts[11]="-o"
ssh_opts[12]="ServerAliveCountMax=20"
if [[ "${EGO_DEBUG-}" -eq 1 ]];then
    # Enable debug mode (bash and ssh client)
    set -vx
    ssh_opts[13]="-vvv"
fi
readonly ssh_opts
readonly timeout_duration="10m"
declare -ri DEFAULT_MMS_MONGODB_PORT=27017
declare -ri DEFAULT_MMS_BLOCKSTORE_MONGODB_PORT=27018
readonly JQ_VERSION="1.6"
readonly MONGOD_INSTALL_DIR="data"
readonly NOHUP_LOG_FILE="${SCRIPT}.log"
readonly NOHUP_PROV_FILE="provision.bash"
declare -i MMS_PORT=9080
declare -i MMS_SSL_PORT=9443
declare -ri MMS_DAEMON_PORT=8087
declare -ri PROXY_PORT=8888
MMS_INSTALL_DIR="/opt/mongodb/mms"

# Commands
NC="$(command -v nc 2>&1 || command -v netcat 2>&1 || echo "Missing netcat commmand" >&2)"
SSH="$(command -v ssh 2>&1 || echo "Missing ssh commmand" >&2)"
TIMEOUT="$(command -v gtimeout 2>&1 || command -v timeout 2>&1 || echo "Missing timeout commmand" >&2)"
if [[ -z "$SSH" || -z "$TIMEOUT" ]]; then
    echo "Cannot proceeed without necessary commands..."
    echo
    exit 2
fi

_mark_versions_set() {
    export INSTALL_VERSION="$1"
}
_are_versions_set() {
    if [[ -z "${INSTALL_VERSION+x}" ]]; then
        return 1
    fi
    return 0
}
_fix_term() {
    # Set a TERM env var
    if [[ -z "${TERM-}" ]]; then
      export TERM="screen-256colorx"
    fi

    # Do not allow Debian distros to have an interactive term
    if [[ "${PLATFORM}" = "debian" || "${PLATFORM}" = "ubuntu" ]]; then
      export DEBIAN_FRONTEND="noninteractive"
    fi
}

# #######################################################
#                   SYSTEM DEPENDENCIES
# #######################################################
readonly E_UNSUPPORTED_DISTRO=145
_unsupported_distro() {
    echo "Unsupported distro..."
    if uname > /dev/null 2>&1; then
        echo
        echo "uname:"
        uname -a
    fi
    if lsb_release > /dev/null 2>&1; then
        echo
        echo "lsb_release:"
        lsb_release -a
    fi
    if [[ -f /etc/SuSe-release ]]; then
        echo
        echo "/etc/SuSe-release:"
        cat /etc/SuSE-release
    fi
    if [[ -f /etc/os-release ]]; then
        echo
        echo "/etc/os-release:"
        cat /etc/os-release
    fi
    exit ${E_UNSUPPORTED_DISTRO}
}
system_info() {
    echo
    echo "System information"
    echo "---------------------"
    echo "Platform: ${PLATFORM}"
    if [[ "${OSVER}" != -1 ]]; then
        echo "OS version: ${OSVER}"
    fi
    echo "MongoDB architecture: ${MDB_ARCH}"
    echo "---------------------"
    echo
}
# Determine architecture and version
_determine_architecture() {
    PLATFORM=""
    OSVER=-1
    MDB_ARCH=""
    if [[ -n ${OS+x} && "Windows_NT" = "${OS}" ]]; then
        PLATFORM="windows"
        MDB_ARCH="x86_64-2008plus-ssl"

    elif uname -a | grep -q Debian > /dev/null 2>&1; then # Debian
        PLATFORM="debian"
        if grep -qE '^10' /etc/debian_version; then
            OSVER=10
            MDB_ARCH="x86_64-debian10"

        elif grep -qE '^9' /etc/debian_version; then
            OSVER=9
            MDB_ARCH="x86_64-debian92"

        elif grep -qE '^8' /etc/debian_version; then
            OSVER=8
            MDB_ARCH="x86_64-debian81"

        else
            _unsupported_distro
        fi

    elif uname -a | grep -q Ubuntu > /dev/null 2>&1; then # Ubuntu
        PLATFORM="ubuntu"
        if lsb_release -a 2>&1 | grep 20.04 > /dev/null 2>&1; then
            OSVER=20
            MDB_ARCH="x86_64-ubuntu2004"

        elif lsb_release -a 2>&1 | grep 18.04 > /dev/null 2>&1; then
            OSVER=18
            MDB_ARCH="x86_64-ubuntu1804"

        elif lsb_release -a 2>&1 | grep 16.04 > /dev/null 2>&1; then
            OSVER=16
            MDB_ARCH="x86_64-ubuntu1604"

        else
            _unsupported_distro
        fi

    elif uname -a | grep -q Darwin; then # Darwin/MacOS
        PLATFORM="macos"
        MDB_ARCH="ssl-x86_64"

    elif lsb_release -a 2>&1 | grep -qE "^Description:\\s+Red Hat.+ 8" > /dev/null; then # Red Hat 8
        PLATFORM="rhel"
        OSVER=8
        MDB_ARCH="x86_64-rhel80"

    elif lsb_release -a 2>&1 | grep -qE "^Description:\\s+Red Hat.+ 7" > /dev/null; then # Red Hat 7
        PLATFORM="rhel"
        OSVER=7
        MDB_ARCH="x86_64-rhel70"

    elif [[ -f /etc/os-release ]] && grep PRETTY /etc/os-release | grep -qE 'Red Hat.+ 8' > /dev/null; then # Red Hat 8
        PLATFORM="rhel"
        OSVER=8
        MDB_ARCH="x86_64-rhel80"

    elif [[ -f /etc/os-release ]] && grep PRETTY /etc/os-release | grep -qE 'Red Hat.+ 7' > /dev/null; then # Red Hat 7
        PLATFORM="rhel"
        OSVER=7
        MDB_ARCH="x86_64-rhel70"

    elif [[ -f /etc/os-release ]] && grep PRETTY /etc/os-release | grep -qE 'Ubuntu 20\.04' > /dev/null; then # Ubuntu 20.04
        PLATFORM="ubuntu"
        OSVER=20
        MDB_ARCH="x86_64-ubuntu2004"

    elif [[ -f /etc/system-release ]] && grep -qE 'Red Hat.+ 8' /etc/system-release > /dev/null; then # Red Hat 8
        PLATFORM="rhel"
        OSVER=8
        MDB_ARCH="x86_64-rhel80"

    elif [[ -f /etc/system-release ]] && grep -qE 'Red Hat.+ 7' /etc/system-release > /dev/null; then # Red Hat 7
        PLATFORM="rhel"
        OSVER=7
        MDB_ARCH="x86_64-rhel70"

    elif lsb_release -a 2>&1 | grep -qE "^Description:\\s+Red Hat.+ 6" > /dev/null; then
        PLATFORM="rhel"
        OSVER=6
        MDB_ARCH="x86_64-rhel62"

    elif [[ -f /etc/os-release ]] && grep PRETTY /etc/os-release | grep -qE 'Red Hat.+ 6' > /dev/null; then # Red Hat 6
        PLATFORM="rhel"
        OSVER=6
        MDB_ARCH="x86_64-rhel62"

    elif [[ -f /etc/system-release ]] && grep -qE 'Red Hat.+ 6' /etc/system-release > /dev/null; then # Red Hat 6
        PLATFORM="rhel"
        OSVER=6
        MDB_ARCH="x86_64-rhel62"

    elif [[ -f /etc/os-release ]] && grep PRETTY /etc/os-release | grep -qE 'SUSE.+15' > /dev/null; then # SUSE 15
        PLATFORM="suse"
        OSVER=15
        MDB_ARCH="x86_64-suse15"

    elif [[ -f /etc/SuSE-release ]] && grep -q SUSE /etc/SuSE-release > /dev/null; then # SUSE
        PLATFORM="suse"
        if grep VERSION /etc/SuSE-release | grep -q 12 > /dev/null; then # SUSE 12
            OSVER=12
            MDB_ARCH="x86_64-suse12"

        elif grep VERSION /etc/SuSE-release | grep -q 15 > /dev/null; then # SUSE 15
            OSVER=15
            MDB_ARCH="x86_64-suse15"

        else
            _unsupported_distro
        fi

    elif [[ -f /etc/issue ]] && grep -qE 'SUSE.+ 12' /etc/issue > /dev/null; then # SUSE 12
        PLATFORM="suse"
        OSVER=12
        MDB_ARCH="x86_64-suse12"

    elif [[ -f /etc/issue ]] && grep -qE 'SUSE.+ 15' /etc/issue > /dev/null; then # SUSE 15
        PLATFORM="suse"
        OSVER=15
        MDB_ARCH="x86_64-suse15"

    elif [[ -f /etc/os-release ]] && grep PRETTY /etc/os-release | grep -q 'Amazon Linux 2' > /dev/null; then # Amazon Linux 2
        PLATFORM="amazon"
        OSVER=2
        MDB_ARCH="x86_64-amazon2"

    elif uname -a | grep -q 'Microsoft'; then # Microsoft Windows Subsystem for Linux
        PLATFORM="wsl"
        MDB_ARCH="-unsupported-mongodb-install-"

    else
        _unsupported_distro
    fi

    # Declare vars are readonly
    readonly PLATFORM
    readonly OSVER
    readonly MDB_ARCH

    # Print platform details
    system_info
}


# #######################################################
#                        HELPERS
# #######################################################
get_host_ip() {
    /sbin/ifconfig | grep -E 'inet[^0-9]+' | sed -E 's/.*inet[^0-9]+([0-9\.]+).*/\1/g' | grep -v 127.0.0.1
}
aws_get_local_ip() {
    _curl -f http://169.254.169.254/latest/meta-data/local-ipv4
}
aws_get_local_hostname() {
    _curl -f http://169.254.169.254/latest/meta-data/local-hostname
}
aws_get_public_ip() {
    _curl -f http://169.254.169.254/latest/meta-data/public-ipv4
}
gcp_get_public_ip() {
    _curl -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/network-interfaces/0/access-configs/0/external-ip
}
get_public_ip() {
    # Makes a best effort guess at the host's IP
    if aws_get_public_ip > /dev/null 2>&1; then
        # Attempt to retrieve the AWS public IP
        aws_get_public_ip
    elif gcp_get_public_ip > /dev/null 2>&1; then
        # or the Google Cloud public IP
        gcp_get_public_ip
    else
        # or default to localhost/IPv4
        echo "127.0.0.1"
    fi
}
service_command() {
    # Parameter check
    if [[ "$#" -lt 2 ]]; then
        echo "Invalid call 'service_command $*'"
        echo "Usage: service_command COMMAND SERVICE_NAME"
        echo
        exit 1
    fi

    COMMAND="$1"
    SERVICE_NAME="$2"
    if proc="$(ps -o comm 1)"; test "${proc#*systemd}" != "$proc"; then
        echo "[SystemD] ${COMMAND} ${SERVICE_NAME}"

       # always give the untruncated status, and do not print the status twice if service_command status is called.
        if [[ "${COMMAND}" = "status" ]] ; then
            systemctl --no-pager status -l "${SERVICE_NAME}.service"
        else
            systemctl --no-pager "${COMMAND}" "${SERVICE_NAME}.service"
            systemctl --no-pager status -l "${SERVICE_NAME}.service"
        fi

    elif command -v service > /dev/null 2>&1; then
        echo "[SysV] ${COMMAND} ${SERVICE_NAME}"
        service "${SERVICE_NAME}" "${COMMAND}"

        if [[ "${COMMAND}" != "status" ]] ; then
            service "${SERVICE_NAME}" status
        fi

    elif [ -f "/etc/init.d/${SERVICE_NAME}" ]; then
        echo "Executing /etc/init.d/${SERVICE_NAME} ${COMMAND}"
        "/etc/init.d/${SERVICE_NAME}" "${COMMAND}"

        if [[ "${COMMAND}" != "status" ]] ; then
            "/etc/init.d/${SERVICE_NAME}" status
        fi
        
    else
        echo "Nothing to do for service ${SERVICE_NAME} ${COMMAND}"
        echo
    fi
}
is_local_port_open() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A port was not supplied!"
        echo "Usage: is_local_port_open PORT"
        echo
        exit 1
    fi

    # Attempt to use netcat, or otherwise resort to bash timeouts and /dev/tcp
    if [ -n "$NC" ]; then
        if "$NC" -w 1 127.0.0.1 "$1" </dev/null >/dev/null 2>&1; then
            echo "Port $1 is open!"
            return 0
        fi
    else
        if "$TIMEOUT" 1s bash -c "cat < /dev/null > /dev/tcp/127.0.0.1/$1" > /dev/null 2>&1; then
            echo "Port $1 is open!"
            return 0
        fi
    fi

    # Return error status if port is not open
    echo "Port $1 is closed!"
    return 1
}
wait_for_open_port() {
    # Parameter check
    if [[ "$#" -lt 2 ]]; then
        echo "Host/port were not supplied!"
        echo "Usage: wait_for_open_port HOST PORT"
        echo
        exit 1
    fi

    echo "Waiting for ${timeout_duration} for port $1:$2 to open..."
    FLAG=""
    if "$TIMEOUT" --foreground 1s echo > /dev/null 2>&1; then
        FLAG="--foreground"
    fi

    if [ -n "$NC" ]; then
        "$TIMEOUT" ${FLAG} ${timeout_duration} bash -c 'while ! '"$NC"' -w 1 '"$1"' '"$2"' </dev/null >/dev/null 2>&1; do printf .; sleep 5; done'
    else
        "$TIMEOUT" ${FLAG} ${timeout_duration} bash -c 'while ! '"$TIMEOUT"' '${FLAG}' 1s bash -c "cat < /dev/null > /dev/tcp/'"$1"'/'"$2"'" > /dev/null 2>&1; do printf .; sleep 5; done'
    fi
    echo "Port $1:$2 is open!"
}
wait_for_open_local_port() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A port was not supplied!"
        echo "Usage: wait_for_open_local_port PORT"
        echo
        exit 1
    fi

    wait_for_open_port 127.0.0.1 "$1"
}
wait_for_closed_port() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "Host/port were not supplied!"
        echo "Usage: wait_for_closed_port PORT"
        echo
        exit 1
    fi

    echo "Waiting for ${timeout_duration} for port $1:$2 to close..."
    FLAG=""
    if "$TIMEOUT" --foreground 1s echo > /dev/null 2>&1; then
        FLAG="--foreground"
    fi
    if [ -n "$NC" ]; then
        "$TIMEOUT" ${FLAG} ${timeout_duration} bash -c 'while '"$NC"' -w 1 '"$1"' '"$2"' </dev/null >/dev/null 2>&1; do printf .; sleep 5; done'
    else
        "$TIMEOUT" ${FLAG} ${timeout_duration} bash -c 'while '"$TIMEOUT"' '${FLAG}' 1s bash -c "cat < /dev/null > /dev/tcp/'"$1"'/'"$1"'" > /dev/null 2>&1; do printf .; sleep 5; done'
    fi
    echo "Port $1:$2 is closed!"
}
wait_for_closed_local_port() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A port was not supplied!"
        echo "Usage: wait_for_closed_local_port PORT"
        echo
        exit 1
    fi

    wait_for_closed_port 127.0.0.1 "$1"
}
replace_property_in_file() {
    # Parameter check
    if [[ "$#" -lt 3 ]]; then
        echo "Invalid call: 'replace_property_in_file $*'"
        echo "Usage: replace_property_in_file FILENAME PROPERTY VALUE"
        echo
        exit 1
    fi

    # Set the new property
    temp_file=$(mktemp)
    grep -vE "^\\s*${2}\\s*=" "${1}" > "${temp_file}" # Export contents minus any lines containing the specified property
    echo "${2}=${3}" >> "${temp_file}"                # Set the new property value
    cat "${temp_file}" > "${1}"                       # Replace the contents of the original file, while preserving any permissions
    rm "${temp_file}"
    echo "Updated property in ${1}: ${2}=${3}"
}

# #######################################################
#                SYSTEM/TEST DEPENDENCIES
# #######################################################

DEPS="unzip curl jq squid openssl nc netcat ncurses-term xdg-utils libxss1 libappindicator1 libindicator7 fonts-liberation libappindicator3-1 libdbusmenu-gtk3-4 libssl1.0-dev"
_wait_for_process_to_finish() {
    echo "Waiting for ${timeout_duration} for $1 to complete any running jobs..."

    "$TIMEOUT" ${timeout_duration} bash -c 'while pgrep '"$1"' > /dev/null 2>&1; do printf .; sleep 5; done'
}
_ensure_tmp_dir_is_writeable() {
    # Attempt to set the appropriate perms, but continue if any of the operations fail
    set +o errexit
    for d in /tmp /var/tmp /data/tmp; do
        echo "Ensure $d is writeable..."
        chmod -R 0777 "$d"
    done
    set -o errexit
}
_install_dep() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A package name was not specified!"
        echo "Usage: _install_dep PACKAGE_NAME"
        echo
        exit 1
    fi

    echo
    echo "Installing dependency: '$1'..."
    if [[ "${PLATFORM}" = "debian" ]] || [[ ${PLATFORM} = "ubuntu" ]]; then # Debian/Ubuntu
        set +o errexit
        ( apt-get install -y -q "$1" && echo "Installed $1" ) || echo "Skipping $1"
        set -o errexit

    elif [[ "${PLATFORM}" = "rhel" ]] || [[ ${PLATFORM} = "amazon" ]]; then # Red Hat / Amazon Linux
        set +o errexit
        ( yum install -y -q "$1" && echo "Installed $1" ) || echo "Skipping $1"
        set -o errexit

    elif [[ "${PLATFORM}" = "suse" ]]; then # SuSe
        set +o errexit
        ( zypper -n -q install --details -- "$1" && echo "Installed $1" ) || echo "Skipping $1"
        set -o errexit

    else
        echo "Could not install '$1'; unsupported package manager or distribution!"
        echo
        _unsupported_distro
    fi
}
resolve_system_dependencies() {
    _ensure_tmp_dir_is_writeable

    echo "Resolving system dependencies..."
    echo
    if [[ "${PLATFORM}" = "debian" ]] || [[ "${PLATFORM}" = "ubuntu" ]]; then # Debian/Ubuntu
        _wait_for_process_to_finish apt
        _wait_for_process_to_finish dpkg
        #apt-get update -y
        #_wait_for_process_to_finish apt
        #_wait_for_process_to_finish dpkg

    elif [[ "${PLATFORM}" = "rhel" ]] || [[ "${PLATFORM}" = "amazon" ]]; then # Red Hat / Amazon Linux
        _wait_for_process_to_finish yum
        #yum update -y --skip-broken

    elif [[ "${PLATFORM}" = "suse" ]]; then # SuSe
        _wait_for_process_to_finish zypper
        #zypper -n update --details

    elif [[ "${PLATFORM}" = "windows" ]]; then # Windows
        echo "Cannot update System Dependencies in Cygwin..."
        echo

        echo "Installing JQ"
        pushd "$(_user_dir)" > /dev/null
        _curl "${curl_opts}" -o "jq.exe" "https://github.com/stedolan/jq/releases/download/jq-${JQ_VERSION}/jq-win64.exe"
        popd > /dev/null

        return
    fi

    # Install dependencies individually
    for dep in ${DEPS}; do
        _install_dep "${dep}"
    done
}
_user_dir() {
    #shellcheck disable=SC2005
    echo "$(cd "${CWD}" && pwd -P)"
}
_curl() {
    $(command -v curl || echo "curl") "$@"
}
link() {
    echo "Linking '${DIR}/${SCRIPT}' in the system path..."

    if [ -d /usr/local/bin ] && ( echo "${PATH}" | grep -q "/usr/local/bin" ); then
        echo "Attempting to link ${SCRIPT} in /usr/local/bin"
        ln -sf "${DIR}/${SCRIPT}" "/usr/local/bin/${SCRIPT}"
        echo "Linked."
    elif [ -d /usr/bin ] && ( echo "${PATH}" | grep -q "/usr/bin" ); then
        echo "Attempting to link ${SCRIPT} in /usr/bin"
        ln -sf "${DIR}/${SCRIPT}" "/usr/bin/${SCRIPT}"
        echo "Linked."
    else
        echo "Could not link ${SCRIPT}; please add it manually to your path:"
        echo "export PATH=${DIR}:\$PATH"
        echo
    fi
}
_set_mongod_vars() {
    if [[ "${PLATFORM}" = "windows" ]]; then # Cygwin
        MONGOD="$(_user_dir)/mongodb/bin/mongod.exe"
        MONGO="$(_user_dir)/mongodb/bin/mongo.exe"
    elif [[ "${PLATFORM}" = "wsl" ]]; then # WSL
        MONGOD="$(command -v mongod)"
        MONGO="$(command -v mongo)"
    else # Standard Linux x86_64
        MONGOD="$(_user_dir)/mongodb/bin/mongod"
        MONGO="$(_user_dir)/mongodb/bin/mongo"
    fi
}

# #######################################################
#                        MONGODB
# #######################################################
_mongodb_archive_name() {
    mdb_arch="${MDB_ARCH}"
    version=$1

    if echo "$1" | grep -q "ent"; then
        # for enterprise versions, the url will look like "mongodb-linux-x86_64-enterprise-rhel57.tgz"
        # So if our desired version input ends in '-ent', add -enterprise to the arch string,
        # then get the version string without '-ent'
        # Note this won't work on PowerPC
        mdb_arch="${mdb_arch//x86_64/x86_64-enterprise}"
        version="${version//-ent/}"
    fi

    if [[ "${PLATFORM}" = "windows" ]]; then
        echo "mongodb-win32-${mdb_arch}-$version.zip"
    else
        echo "mongodb-linux-${mdb_arch}-$version.tgz"
    fi
}
download_mongodb() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A version was not supplied!"
        echo "Usage: download_mongodb VERSION"
        echo
        exit 1
    fi

    if [[ -d "$(_user_dir)/mongodb" ]]; then
        echo "MongoDB already present on the host system, skipping..."
        echo
        return
    fi

    local root_download_url="https://fastdl.mongodb.org"
    if echo "$1" | grep -q "ent"; then
        root_download_url="https://downloads.mongodb.com"
    fi

    local file_name
    file_name=$(_mongodb_archive_name "$1")
    pushd "$(_user_dir)" > /dev/null
    if [[ "${PLATFORM}" = "windows" ]]; then
        local archive="${root_download_url}/win32/${file_name}"
        echo "Downloading ${archive}..."
        _curl "${curl_opts}" -o "${file_name}" "${archive}"
        unzip "${file_name}" > /dev/null
    else
        local archive="${root_download_url}/linux/${file_name}"
        echo "Downloading ${archive}..."
        _curl "${curl_opts[@]}" -o "${file_name}" "${archive}"
        tar zxf "${file_name}"
    fi

    local final_dir
    final_dir="$(_user_dir)"/mongodb

    # Move database to final location
    rm -f "${file_name}"
    local mdb_dir="${file_name%.*}"
    mv "${mdb_dir}" "${final_dir}"
    echo "Downloaded ${archive} and deployed at ${final_dir}..."

    # For enterprise builds, install the Visual Studio redistributable
    if [[ "${PLATFORM}" = "windows" ]] && echo "${file_name}" | grep -q "enterprise"; then
        echo "Installing VC redist for MongoDB..."
        chmod +x "${final_dir}/vcredist_x64.exe"
        "${final_dir}/vcredist_x64.exe" /quiet /norestart || echo "VC redist might already be installed..."
    fi

    # Set perms
    chmod +x "${final_dir}"/bin/*

    popd > /dev/null
}
_uninstall_mongodb() {
    if [ ! -d "$(_user_dir)"/mongodb ]; then
        echo "MongoDB is not present on the host system, skipping..."
        echo
        return
    fi

    echo "Removing MongoDB from host system"
    echo
    rm -rf "$(_user_dir)"/mongodb
}

# #######################################################
#                 START MONGODB INSTANCE
# #######################################################
start_mongodb() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A port was not supplied!"
        echo "Usage: start_mongodb PORT [BIND_IP/'bind_ip_all'] [OPTIONS]"
        echo
        exit 1
    fi

    port=$1
    shift

    local bind_ip="127.0.0.1"
    if [[ "$#" -gt 0 ]]; then
        bind_ip=$1
        shift
    fi

    local bind_ip_option="--bind_ip ${bind_ip}"
    if [[ "${bind_ip}" = "bind_ip_all" ]]; then
        bind_ip="0.0.0.0"
        bind_ip_option="--bind_ip_all"
    fi

    _set_mongod_vars

    if "${MONGO}" --port "${port}" --eval "db.hostInfo()" > /dev/null 2>&1; then
        echo "Found previously running MongoD on ${port}; skipping start..."
        return
    fi

    # Create data dir
    mkdir -p "$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}"

    # Ensure that the log file is readable/writeable by any user
    touch "$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}/mongod.log"
    chmod 0777 "$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}/mongod.log"

    # Start Mongod
    echo "Starting MongoDB on ${port}, binding on ${bind_ip}..."
    local extra_options="$*"
    if [[ "${PLATFORM}" = "windows" ]]; then
        # dbpath must be in Windows formatting for mongod to find it (it won't be resolved in cygwin)
        dbpath=$(cygpath --windows "$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}")
        logfile=$(cygpath --windows "$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}/mongod.log")

        # shellcheck disable=SC2086
        screen -fn -d -m "${MONGOD}" --port "${port}" \
                                     --logpath="${logfile}" \
                                     --logappend \
                                     --dbpath="${dbpath}" \
                                     --storageEngine=wiredTiger \
                                     --wiredTigerCacheSizeGB 0.5 \
                                     ${bind_ip_option} \
                                     --oplogSize=100 \
                                     ${extra_options};
    else
        # shellcheck disable=SC2086
        "${MONGOD}" --port "${port}" \
                    --logpath="$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}/mongod.log" \
                    --logappend \
                    --dbpath="$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}" \
                    --storageEngine=wiredTiger \
                    --wiredTigerCacheSizeGB 0.5 \
                    ${bind_ip_option} \
                    --oplogSize=100 \
                    --fork \
                    ${extra_options};
    fi

    echo "Polling MongoD in 5 second intervals..."
    while ! "$MONGO" --port "${port}" --eval "db.hostInfo()" > /dev/null 2>&1 ; do echo '.'; sleep 5; done;
    echo "MongoD is running!"
    echo
}
stop_mongodb() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A port was not supplied!"
        echo "Usage: stop_mongodb PORT"
        echo
        exit 1
    fi

    # Check for running mongod-s
    if ! is_local_port_open "$1"; then
        echo "MongoDB is not running; skipping stop!"
        return
    fi

    _set_mongod_vars

    # Stop MongoD
    echo "Stopping MongoDB on port $1..."
    "$MONGO" admin --port "$1" --eval "db.shutdownServer()" ||  pkill -f "mongod.*$1" || echo "Failed to stop MongoDB on port $1" >&2

    wait_for_closed_local_port "$1"
    echo "MongoDB has stopped running!"
}

# #######################################################
#                 INSTALL MMS PACKAGE
# #######################################################
_get_mms_config_file() {
    if [[ "${PLATFORM}" = "windows" ]]; then
       echo "/cygdrive/c/MMSData/Server/Config/conf-mms.properties"
    else
       echo "${MMS_INSTALL_DIR}/conf/conf-mms.properties"
    fi
}
_get_mms_archive() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "The first parameter should either be a file, URL, or an extension!"
        echo "Usage: _get_mms_archive /path/to/file.tar.gz"
        echo "Usage: _get_mms_archive tar.gz"
        echo
        exit 1
    fi

    local ext
    if [ -f "$1" ]; then # file
        ext="${1##*/}" # get the file's name
        ext="${ext#*.}"  # get the file's extension
    elif [[ "$1" == http* ]]; then # URL
        ext="${1##*/}" # get the last path component
        if [[ "$ext" =~ ^.*tar\.gz$ ]]; then
            # handle .tar.gz separately, since it has two dots
            ext="tar.gz"
        else
            ext="${ext##*.}" # get the last extension part
        fi
    else # extension
        ext="$1"
    fi

    echo "ops_manager.${ext}"
}
_release_archive_name() {
    echo "ops_manager_release_archive.$(date +%Y-%m-%d).json"
}
_ensure_release_archive() {
    mkdir -p "$(_user_dir)/.ego"
    pushd "$(_user_dir)/.ego" > /dev/null
    if [ ! -f "$(_release_archive_name)" ]; then
        _curl "${curl_opts}" -o "$(_release_archive_name)" "https://info-mongodb-com.s3.amazonaws.com/com-download-center/ops_manager_release_archive.json"
    fi
    popd > /dev/null
}
_find_om_archive_by_version() {
    _ensure_release_archive
    
    if [[ "$#" -lt 3 ]]; then
        echo "Usage: _find_om_archive_by_version VERSION ARCH PACKAGE_FORMAT FILE_TYPE"
        echo "e.g.: _find_om_archive_by_version 4.0.0 x86_64 deb deb"
        echo
        exit 1
    fi
    VERSION="$1"
    ARCH="$2"
    PACKAGE_FORMAT="$3"
    FILE_TYPE="$4"
    
    local result
    result=$(jq -r -c '.currentReleases[], .oldReleases[] 
        | select( .version | contains("'"${VERSION}"'")) 
        | .platform[] | select (.arch=="'"${ARCH}"'") 
        | select ( .package_format | contains("'"${PACKAGE_FORMAT}"'")) 
        | .packages.links[] | select(.name=="'"${FILE_TYPE}"'") 
        | .download_link' < "$(_user_dir)/.ego/$(_release_archive_name)")
    echo "${result}"
}
_identify_installable_om_archive() {
    local package_format=
    if [[ "${PLATFORM}" = "windows" ]]; then
        package_format="msi"

    elif [[ "${PLATFORM}" = "debian" ]] || [[ "${PLATFORM}" = "ubuntu" ]]; then # Debian/Ubuntu
        package_format="deb"

    elif [[ "${PLATFORM}" = "rhel" ]] || [[ "${PLATFORM}" = "amazon" ]] || [[ "${PLATFORM}" = "suse" ]]; then # Red Hat/Amazon Linux/SuSe
        package_format="rpm"
    else
        _unsupported_distro
    fi

    local version=
    local tgz="${package_format}"

    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --version) version="$2"; shift 2;;
            --tgz) tgz="tar.gz"; shift;;
            * ) echo "Invalid configuration option: '$1'" ; exit 1 ;;
        esac
    done

    # Parameter check
    if [[ -z "$version" ]]; then
        echo "A version was not supplied!"
        echo "Usage: _identify_installable_om_archive --version VERSION [--tgz]"
        echo
        exit 1
    fi

    _find_om_archive_by_version "$version" "x86_64" "$package_format" "$tgz"
}
_download_ops_manager() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "The Ops Manager archive was not supplied!"
        echo "Usage: _download_ops_manager OPS_MANAGER_ARCHIVE"
        echo
        exit 1
    fi
    local archive="$1"

    local local_file
    local_file="$(_get_mms_archive "${archive}")"

    pushd "$(_user_dir)" > /dev/null
    echo "Downloading Ops Manager: ${archive} to ${local_file}..."
    _curl "${curl_opts}" -o "${local_file}" "${archive}"
    echo "Downloaded ${archive} to ${local_file}..."
    popd > /dev/null
}
_skip_ops_manager_registration_wizard() {
    echo "Skipping Ops Manager Registration Wizard..."
    echo
    replace_property_in_file "$(_get_mms_config_file)" "mms.ignoreInitialUiSetup" "true"
    replace_property_in_file "$(_get_mms_config_file)" "mms.fromEmailAddr" "noreply@example.com"
    replace_property_in_file "$(_get_mms_config_file)" "mms.replyToEmailAddr" "noreply@example.com"
    replace_property_in_file "$(_get_mms_config_file)" "mms.adminEmailAddr" "noreply@example.com"
    replace_property_in_file "$(_get_mms_config_file)" "mms.mail.transport" "smtp"
    replace_property_in_file "$(_get_mms_config_file)" "mms.mail.hostname" "127.0.0.1"
    replace_property_in_file "$(_get_mms_config_file)" "mms.mail.port" "25"
    replace_property_in_file "$(_get_mms_config_file)" "mms.mail.ssl" "false"
}
_configure_ops_manager() {
    _set_mongod_vars

    # Replace MMS install directory on Windows
    if [[ "${PLATFORM}" = "windows" ]]; then
        MMS_INSTALL_DIR="C:\\\\MMSData"
    fi

    # Read properties
    local skip_registration_wizard=0
    local appdb_url=
    local central_url=
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --install-dir) MMS_INSTALL_DIR="$2"; shift 2;;
            --skip-registration-wizard) skip_registration_wizard=1; shift;;
            --appdb-url) appdb_url="$2"; shift 2;;
            --central-url) central_url="$2"; shift 2;;
            * ) echo "Invalid configuration option: '$1'" ; exit 1 ;;
        esac
    done

    echo "Configuring Ops Manager..."
    if [[ "${PLATFORM}" = "windows" ]]; then
        replace_property_in_file "$(_get_mms_config_file)" "rootDirectory" "${MMS_INSTALL_DIR}\\\\BackupData\\\\"

        # Forward the ports if not using default values
        # Solution taken from: https://stackoverflow.com/questions/11525703/port-forwarding-in-windows
        if [[ "${MMS_PORT}" != "8080" ]]; then
            netsh interface portproxy add v4tov4 listenport="${MMS_PORT}" listenaddress=0.0.0.0 connectport=8080 connectaddress="$(aws_get_local_ip)"
        fi
        if [[ "${MMS_SSL_PORT}" != "8443" ]]; then
            netsh interface portproxy add v4tov4 listenport="${MMS_SSL_PORT}" listenaddress=0.0.0.0 connectport=8443 connectaddress="$(aws_get_local_ip)"
        fi

        # Force the automation release dir (expected by E2E tests)
        # NOTE: This value needs to match what is defined by the E2E tests, otherwise the OnPrem Generic E2E tests will fail
        replace_property_in_file "$(_get_mms_config_file)" "automation.versions.directory" "${MMS_INSTALL_DIR}\\\\MongoDBReleases\\\\"

    else
        # Configure backup head
        local backup_dir="${MMS_INSTALL_DIR}/head"
        mkdir -p "${backup_dir}" && echo "Created directory: ${backup_dir}..."
        if id -u mongodb-mms > /dev/null 2>&1; then
            # only chown if the user exists (not true for tgz)
            chown mongodb-mms:mongodb-mms "${backup_dir}"
        fi
        replace_property_in_file "$(_get_mms_config_file)" "rootDirectory" "${backup_dir}/"

        # Configure ports
        replace_property_in_file "${MMS_INSTALL_DIR}/conf/mms.conf" "BASE_PORT" "${MMS_PORT}"
        replace_property_in_file "${MMS_INSTALL_DIR}/conf/mms.conf" "BASE_SSL_PORT" "${MMS_SSL_PORT}"

        # Define and create the release automation dir, if not defined
        local automation_release_dir="${MMS_INSTALL_DIR}/mongodb-releases/"
        mkdir -p "${automation_release_dir}"
        chmod -R 0777 "${automation_release_dir}"

        # Force the automation release dir (expected by E2E tests)
        # NOTE: This value needs to match what is defined by the E2E tests, otherwise the OnPrem Generic E2E tests will fail
        replace_property_in_file "$(_get_mms_config_file)" "automation.versions.directory" "${automation_release_dir}"
    fi

    # Set extra properties
    if [[ "${skip_registration_wizard}" -eq 1 ]]; then
        _skip_ops_manager_registration_wizard
    fi

    if [[ -n "${appdb_url}" ]]; then
        replace_property_in_file "$(_get_mms_config_file)" "mongo.mongoUri" "${appdb_url}"
    fi

    if [[ -n "${central_url}" ]]; then
        replace_property_in_file "$(_get_mms_config_file)" "mms.centralUrl" "${central_url}"
    fi
}
_is_tgz() {
    local local_file
    local_file="$(_get_mms_archive "$1")"
    local ext="${local_file#*.}"
    if [[ "${ext}" = "tgz" || "${ext}" = "tar.gz" ]]; then
        return 0 # true
    else
        return 1 # false
    fi
}
_get_tgz_install_dir() {
    # Return the default install dir for tgz-s
    echo "$(_user_dir)/mongodb-mms"
}
_install_ops_manager() {
    pushd "$(_user_dir)" > /dev/null

    # Determine if this is an upgrade operation
    local upgrade=0
    local archive=
    while [[ "$#" -gt 0 ]]; do
      case "$1" in
        --upgrade) upgrade=1; shift ;;
        --archive) archive="$2"; shift 2;;
        * ) echo "Invalid configuration option: '$1'" ; exit 1 ;;
      esac
    done

    # specify RPM upgrade options
    declare -a rpm_flags
    rpm_flags[0]="-ivh" # install package by default
    if [[ "$upgrade" -eq 1 ]]; then
        rpm_flags[0]="-Uvh"
        rpm_flags[1]="--oldpackage"
    fi

    local local_file
    local_file="$(_get_mms_archive "${archive}")"
    if [[ ! -f "${local_file}" ]]; then
        echo "Cannot install Ops Manager: ${local_file} does not exist!"
        echo
        exit 1
    fi

    if _is_tgz "${archive}" && [[ "${PLATFORM}" != "windows" ]]; then
        echo "Installing Ops Manager from a tar.gz"
        echo
        local install_dir
        install_dir="$(_get_tgz_install_dir)"
        mkdir -p "${install_dir}"
        
        echo "Extracting tgz: ${local_file} to ${install_dir}..."
        tar -xzf "${local_file}" -C "${install_dir}" --strip-components 1

    elif [[ "${PLATFORM}" = "windows" ]]; then
        if [ "${upgrade}" -eq 1 ]; then
            echo "Upgrading Ops Manager on Windows is not supported"
            echo
            exit 1
        fi
        
        echo "Installing the VS2013 redistributable..."
        echo
        _curl "${curl_opts}" -o vcredist_x64.exe https://download.microsoft.com/download/2/E/6/2E61CFA4-993B-4DD4-91DA-3737CD5CD6E3/vcredist_x64.exe
        chmod +x vcredist_x64.exe
        ./vcredist_x64.exe /quiet /norestart || echo "VC redist 2013 for Ops Manager might already be installed..."
        rm -f vcredist_x64.exe

        echo "Installing Ops Manager (${local_file})..."
        msiexec /passive /i "${local_file}" || echo "Ops Manager might already be installed..."
        rm -f "${local_file}"

    elif [[ "${PLATFORM}" = "debian" ]] || [[ ${PLATFORM} = "ubuntu" ]]; then # Debian/Ubuntu
        echo "Installing Ops Manager (${local_file})..."
        _wait_for_process_to_finish apt
        _wait_for_process_to_finish dpkg
        dpkg -i --force-confnew "${local_file}"
        rm -f "${local_file}"

    elif [[ "${PLATFORM}" = "rhel" ]] || [[ ${PLATFORM} = "amazon" ]] || [[ ${PLATFORM} = "suse" ]]; then # Red Hat/Amazon Linux
        echo "Installing Ops Manager (${local_file})..."
        _wait_for_process_to_finish yum

        rpm "${rpm_flags[@]}" "${local_file}"
        rm -f "${local_file}"

    elif [[ ${PLATFORM} = "suse" ]]; then # SuSe
        echo "Installing Ops Manager (${local_file})..."
        _wait_for_process_to_finish zypper

        rpm "${rpm_flags[@]}" "${local_file}"
        rm -f "${local_file}"

    else
        echo "Unsupported combination of options or something went wrong: $*"
        echo "Exiting!"
        echo
        exit 1
    fi

    popd > /dev/null
}
_find_installed_package() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A package name was not supplied!"
        echo "Usage: _find_installed_package PACKAGE_NAME"
        echo
        exit 1
    fi

    if [[ "${PLATFORM}" = "windows" ]]; then
        echo "Finding installed packages is not supported on Windows"
        exit 1

    elif [[ "${PLATFORM}" = "debian" ]] || [[ "${PLATFORM}" = "ubuntu" ]]; then # Debian/Ubuntu
        set +o errexit # do not fail here
        dpkg --get-selections | grep -v "deinstall" | grep -s "$1" | awk '{print $1}'
        set -o errexit

    elif [[ "${PLATFORM}" = "rhel" ]] || [[ "${PLATFORM}" = "amazon" ]] || [[ "${PLATFORM}" = "suse" ]]; then # Red Hat/Amazon Linux/SuSe
        set +o errexit # do not fail here
        rpm -qa | grep "$1"
        set -o errexit
    fi
}
_uninstall_ops_manager() {
    echo "Uninstalling Ops Manager..."
    installed_package="$(_find_installed_package mongodb-mms)"
    
    # Default TGZ install dir
    local install_dir
    install_dir="$(_get_tgz_install_dir)"

    if [[ ! -d "${install_dir}" && -z "$installed_package" ]]; then
        echo "Ops Manager is not present on this host. Skipping uninstall..."
        echo
        return
    fi

    set +o errexit # do not fail here
    echo "Uninstalling ${installed_package}..."
    if [ -d "${install_dir}" ]; then
        echo "Deleting ${install_dir}..."
        rm -rf "${install_dir}"

    elif [[ "${PLATFORM}" = "debian" ]] || [[ ${PLATFORM} = "ubuntu" ]]; then # Debian/Ubuntu
        dpkg -r "${installed_package}"

    elif [[ "${PLATFORM}" = "rhel" ]] || [[ ${PLATFORM} = "amazon" ]] || [[ ${PLATFORM} = "suse" ]]; then # Red Hat/Amazon Linux/SuSe
        rpm -e "${installed_package}"

    else
        echo "Uninstalling (${installed_package}) is not supported on Windows..."
        echo
    fi
    set -o errexit
}

# #######################################################
#                    START OPS MANAGER
# #######################################################
_is_running_ssl() {
    if grep -q "mms.https.PEMKeyFile" "$(_get_mms_config_file)" > /dev/null 2>&1; then
        return 0
    fi
    return 1
}
get_om_port() {
    if _is_running_ssl; then
        echo ${MMS_SSL_PORT}
    else
        echo ${MMS_PORT}
    fi
}
get_om_scheme() {
    if _is_running_ssl; then
        echo "https"
    else
        echo "http"
    fi
}
start_ops_manager() {
    local port
    port="$(get_om_port)"

    local do_not_wait_for_port=0
    local do_not_wait_for_daemon=0
    local archive=
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --skip-waiting-for-service-start) do_not_wait_for_port=1 ; shift ;;
            --skip-waiting-for-daemon) do_not_wait_for_daemon=1 ; shift ;;
            --archive) archive="$2"; shift 2;;
            * ) echo "Invalid configuration option: $1" ; exit 1 ;;
        esac
    done

    if [[ "${PLATFORM}" = "windows" ]]; then # Windows
        # On Windows we start on the default port and forward MMS_PORT to it
        # for this check, we need to verify the standard port
        port=8080
    fi

    if is_local_port_open "${port}"; then
        echo "Found previously running Ops Manager service; skipping start."
        echo
        return
    fi

    if _is_tgz "${archive}"; then
        if [[ "${PLATFORM}" = "windows" ]]; then
            echo "Cannot start Ops Manager from tgz on Windows..."
            echo
            exit 1
        fi

        local install_dir
        install_dir="$(_get_tgz_install_dir)"
        local enc_key_path="${install_dir}/.mongodb-mms/gen.key"
        if [ ! -f "${enc_key_path}" ]; then
            echo "Generating a new Encryption Key: ${enc_key_path}..."
            "${install_dir}"/bin/mms-gen-key -f "${enc_key_path}"
        fi

        echo "Starting Ops Manager as the current user (${USER})..."
        nohup "${install_dir}"/bin/start-mongodb-mms --enc-key-path "${enc_key_path}" > "${NOHUP_LOG_FILE}" 2>&1 &

    elif [[ "${PLATFORM}" = "windows" ]]; then # Windows
        echo "Starting Ops Manager..."
        net start "MongoDB Ops Manager HTTP Service"

        if [[ "${do_not_wait_for_port}" -eq 0 ]]; then
            echo "Waiting for Ops Manager to start..."
            wait_for_open_local_port "${port}"
            echo "Ops Manager is running."
        fi

        echo "Starting the Backup Daemon..."
        net start "MongoDB Backup Daemon Service"

    else # Standard Linux
        echo "Starting Ops Manager and the Backup Daemon..."
        service_command start mongodb-mms

        if [[ "${do_not_wait_for_port}" -eq 0 ]]; then
            echo "Waiting for Ops Manager to start..."
            wait_for_open_local_port "${port}"
            echo "Ops Manager is running."
        fi
    fi

    if [[ "${do_not_wait_for_daemon}" -eq 0 ]]; then
        echo "Waiting for the Backup Daemon to start..."
        wait_for_open_local_port "${MMS_DAEMON_PORT}"
        echo "The Backup Daemon is running."
    fi
}
stop_ops_manager() {
    local port
    port="$(get_om_port)"

    local do_not_wait_for_port=0
    local do_not_wait_for_daemon=0
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --skip-waiting-for-service-start) do_not_wait_for_port=1 ; shift ;;
            --skip-waiting-for-daemon) do_not_wait_for_daemon=1 ; shift ;;
            * ) echo "Invalid configuration option: $1" ; exit 1 ;;
        esac
    done

    if [[ "${PLATFORM}" = "windows" ]]; then # Windows
        # On Windows we start on the default port and forward MMS_PORT to it
        # use the default port for checks
        port=8080
    fi

    if ! is_local_port_open "${port}"; then
        echo "Ops Manager is not running; skipping stop."
        echo
        return
    fi

    # Default TGZ install dir
    local install_dir
    install_dir="$(_get_tgz_install_dir)"

    set +o errexit  # do not fail here
    if [ -d "${install_dir}" ] && [[ "${PLATFORM}" != "windows" ]]; then
        echo "Killing all Ops Manager and Backup Daemon processes..."
        pgrep mms-app | xargs -I{} kill -9 {}

    elif [[ "${PLATFORM}" = "windows" ]]; then # Windows
        echo "Stopping Ops Manager..."
        net stop "MongoDB Backup Daemon Service"

        echo "Stopping the Backup Daemon..."
        net stop "MongoDB Ops Manager HTTP Service"

    else # Standard Linux
        echo "Stopping Ops Manager and the Backup Daemon..."
        service_command stop mongodb-mms
    fi
    set -o errexit

    if [[ "${do_not_wait_for_port}" -eq 0 ]]; then
        echo "Waiting for Ops Manager to stop..."
        wait_for_closed_local_port "${port}"
        echo "Ops Manager is not running."
    fi

    if [[ "${do_not_wait_for_daemon}" -eq 0 ]]; then
        echo "Waiting for the Backup Daemon to stop..."
        wait_for_closed_local_port "${MMS_DAEMON_PORT}"
        echo "The Backup Daemon is not running."
    fi
}
restart_ops_manager() {
    stop_ops_manager || echo "Stopped..."
    start_ops_manager
}

# #######################################################
#                   IPTABLES DEFINITIONS
# #######################################################
_iptables_allow_localhost() {
    iptables -A INPUT  --in-interface  lo --jump ACCEPT
    iptables -A OUTPUT --out-interface lo --jump ACCEPT
}
_iptables_allow_http_mms_ports() {
    # MMS ports
    if _is_running_ssl; then
        iptables -A INPUT  --proto tcp --dport "${MMS_SSL_PORT}" --jump ACCEPT
        iptables -A OUTPUT --proto tcp --sport "${MMS_SSL_PORT}" --jump ACCEPT
    else
        iptables -A INPUT  --proto tcp --dport "${MMS_PORT}"     --jump ACCEPT
        iptables -A OUTPUT --proto tcp --sport "${MMS_PORT}"     --jump ACCEPT
    fi
}
_iptables_allow_dns() {
    # Allow DNS traffic
    iptables -A INPUT  --proto udp --sport 53 --jump ACCEPT
    iptables -A OUTPUT --proto udp --dport 53 --jump ACCEPT
    iptables -A INPUT  --proto tcp --sport 53 --jump ACCEPT
    iptables -A OUTPUT --proto tcp --dport 53 --jump ACCEPT
}
_iptables_allow_ssh() {
    # Allow SSH traffic
    iptables -A INPUT  --proto tcp --dport 22 --jump ACCEPT
    iptables -A OUTPUT --proto tcp --sport 22 --jump ACCEPT
}
_iptables_allow_subnet() {
    # Allow access over AWS's private IP net
    iptables -A INPUT  --dest "$(get_host_ip)/16" --jump ACCEPT
    iptables -A OUTPUT --dest "$(get_host_ip)/16" --jump ACCEPT
}
_iptables_allow_aws_meta() {
    # Allow AWS's metadata endpoint
    _iptables_allow_host 169.254.169.254
}
_iptables_deny_all() {
    # Always allow established connections
    iptables -A INPUT  --match state --state ESTABLISHED,RELATED --jump ACCEPT
    iptables -A OUTPUT --match state --state ESTABLISHED,RELATED --jump ACCEPT

    # Drop everything else
    iptables -A INPUT  -p udp -j REJECT --reject-with icmp-port-unreachable
    iptables -A OUTPUT -p udp -j REJECT --reject-with icmp-port-unreachable
    iptables -A INPUT  -p tcp -j REJECT --reject-with tcp-reset
    iptables -A OUTPUT -p tcp -j REJECT --reject-with tcp-reset
}
_iptables_allow_all() {
    if ! command -v iptables >/dev/null 2>&1; then
        echo "The iptables utility is not available; cannot set firewall rules..."
        echo
        return
    fi

    # Reset the access policies to prevent getting locked out
    iptables --policy INPUT   ACCEPT
    iptables --policy OUTPUT  ACCEPT
    iptables --policy FORWARD ACCEPT
    iptables --zero
    iptables --flush
}
_iptables_allow_host() {
    # Allow access to/from the specified host
    iptables -I INPUT  1 --dest "$1/32" --jump ACCEPT
    iptables -I OUTPUT 2 --dest "$1/32" --jump ACCEPT
}
_iptables_allow_outgoing_for_user() {
    # Allow HTTP/S traffic for a given user
    iptables -I OUTPUT 1 --proto tcp --dport  80 --match state --match owner --uid-owner "$1" --state NEW,ESTABLISHED --jump ACCEPT
    iptables -I OUTPUT 2 --proto tcp --dport 443 --match state --match owner --uid-owner "$1" --state NEW,ESTABLISHED --jump ACCEPT
}
iptables_default_http_redirect() {
    # Redirect 80 to MMS_PORT
    iptables -I INPUT 1 -p tcp --dport 80 -j ACCEPT
    iptables -I INPUT 2 -p tcp --dport "${MMS_PORT}" -j ACCEPT
    iptables -A PREROUTING -t nat -p tcp --dport 80 -j REDIRECT --to-port "${MMS_PORT}"
    # Redirect 443 to MMS_SSL_PORT
    iptables -I INPUT 3 -p tcp --dport 443 -j ACCEPT
    iptables -I INPUT 4 -p tcp --dport "${MMS_SSL_PORT}" -j ACCEPT
    iptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port "${MMS_SSL_PORT}"
}
_iptables_show() {
    if ! command -v iptables >/dev/null 2>&1; then
        echo "The iptables utility is not available; cannot set firewall rules..."
        echo
        return
    fi

    # Show current iptables rules
    echo
    echo "Current iptables rules:"
    echo
    iptables -L
    echo
}
# shellcheck disable=SC2120
network_access_restrict() {
    if [[ "${PLATFORM}" = "windows" ]]; then
        echo "Cannot use iptables in Cygwin..."
        return
    fi

    echo "Restricting outgoing network access to all users but root, and the system proxy user."
    echo "Note: To completely disallow network access, call 'network_access_restrict --strict'"
    echo

    # Restore to defaults
    _iptables_allow_all

    # Allow network access for a few system users, unless '--strict` was specified
    if [[ "$#" -ne 1 || $1 != "--strict" ]]; then
        _iptables_allow_outgoing_for_user root

        # Allow potential proxy users outgoing access
        if getent passwd proxy > /dev/null; then
            _iptables_allow_outgoing_for_user proxy
        fi
        if getent passwd squid > /dev/null; then
            _iptables_allow_outgoing_for_user squid
        fi
    fi

    # Configure access policies
    _iptables_allow_localhost
    _iptables_allow_ssh
    _iptables_allow_http_mms_ports
    _iptables_allow_dns
    _iptables_allow_aws_meta
    _iptables_allow_subnet
    _iptables_allow_host "$(get_public_ip)"
    _iptables_deny_all
    _iptables_show
}
network_access_open() {
    if [[ "${PLATFORM}" = "windows" ]]; then
        echo "Cannot use iptables in Cygwin..."
        return
    fi

    # Allow internet traffic to all hosts
    echo "Allowing outgoing network access"
    echo

    _iptables_allow_all
    _iptables_show
}


# #######################################################
#             INSTALL THE SQUID PROXY SERVER
# #######################################################
configure_proxy() {
    if [[ "${PLATFORM}" = "windows" ]]; then
        echo "Cannot set up Squid in Cygwin!"
        return

    elif [[ -z "$(_find_installed_package squid)" ]]; then
        echo "Squid is not installed on this system! Skipping Proxy configuration..."
        echo
        return
    fi

    echo "# Ops Manager proxy config"                | tee    /etc/squid/squid.conf
    if [[ "${PLATFORM}" = "rhel" && ${OSVER} = 6 ]] || [[ ${PLATFORM} = "debian" && ${OSVER} = 7 ]]; then
        echo ""                                      | tee -a /etc/squid/squid.conf
        echo "# Define ACLs in older Squid versions" | tee -a /etc/squid/squid.conf
        echo "acl localhost src 127.0.0.1/32"        | tee -a /etc/squid/squid.conf
        echo "acl manager proto cache_object"        | tee -a /etc/squid/squid.conf
        echo "acl all src 0.0.0.0/0.0.0.0"           | tee -a /etc/squid/squid.conf
    fi
    echo ""                                          | tee -a /etc/squid/squid.conf
    echo "# Squid settings"                          | tee -a /etc/squid/squid.conf
    echo "http_port ${PROXY_PORT}"                   | tee -a /etc/squid/squid.conf
    echo "cache deny all"                            | tee -a /etc/squid/squid.conf
    echo ""                                          | tee -a /etc/squid/squid.conf
    echo "# Allow localhost"                         | tee -a /etc/squid/squid.conf
    echo "http_access allow localhost"               | tee -a /etc/squid/squid.conf
    echo ""                                          | tee -a /etc/squid/squid.conf
    echo "# Allow local subnet"                      | tee -a /etc/squid/squid.conf
    echo "acl localnet src $(get_host_ip)/16"        | tee -a /etc/squid/squid.conf
    echo "http_access allow localnet"                | tee -a /etc/squid/squid.conf
    echo ""                                          | tee -a /etc/squid/squid.conf
    echo "# Deny everything else"                    | tee -a /etc/squid/squid.conf
    echo "http_access deny manager"                  | tee -a /etc/squid/squid.conf
    echo "http_access deny all"                      | tee -a /etc/squid/squid.conf
    echo ""                                          | tee -a /etc/squid/squid.conf

    echo "Restarting squid..."
    service_command restart squid
    
    echo "Waiting for squid to start..."
    wait_for_open_local_port "${PROXY_PORT}"
}

ulimits() {
    # Increase the number of maximum open files
    # see https://www.mongodb.com/blog/post/tuning-mongodb--linux-to-allow-for-tens-of-thousands-connections
    echo "*           soft    nofile          9999999" | sudo tee -a /etc/security/limits.conf
    echo "*           hard    nofile          9999999" | sudo tee -a /etc/security/limits.conf
    echo "*           soft    nproc           9999999" | sudo tee -a /etc/security/limits.conf
    echo "*           hard    nproc           9999999" | sudo tee -a /etc/security/limits.conf
    echo "*           soft    stack           9999999" | sudo tee -a /etc/security/limits.conf
    echo "*           hard    stack           9999999" | sudo tee -a /etc/security/limits.conf
    sysctl -w fs.file-max=9999999
    sysctl -p
}


# #######################################################
#                           SSL
# #######################################################
ssl_generate_server_certificate() {
    if [[ "$#" -eq 0 || -z "$1" ]]; then
        ssl_hostname="$(get_public_ip)"
        echo "A hostname was not specified; defaulting to: ${ssl_hostname}"
        echo
    else
        ssl_hostname="$1"
    fi

    if [[ "${PLATFORM}" = "windows" ]]; then # Windows
        echo "Configuring SSL on Windows is not supported!"
        echo
        exit 1
    fi

    if [ -f "/etc/ssl/${ssl_hostname}.pem" ]; then
        echo "A certificate for ${ssl_hostname} was already generated; will not regenerate..."
        echo
        return
    fi

    echo "Generating root and ssl certs for ${ssl_hostname}"
    echo

    # CREATE A ROOT CA
    pushd "$(_user_dir)" > /dev/null
    openssl genrsa -out rootCA.key 2048
    openssl req -x509 -new -nodes -key rootCA.key -days 365 -out rootCA.crt -subj "/C=IE/ST=D/L=Dublin/O=DO NOT TRUST/OU=DO NOT TRUST/CN=DO NOT TRUST"
    cat rootCA.crt rootCA.key > rootCA.pem

    # Create the Certificate for the Ops Manager Server
    echo keyUsage=critical, digitalSignature, keyEncipherment > serverCertOpts
    echo extendedKeyUsage = serverAuth > serverCertOpts
    openssl genrsa -out "${ssl_hostname}.key" 2048
    openssl req -new -key "${ssl_hostname}.key" -out "${ssl_hostname}.csr" -subj "/C=IE/ST=D/L=Dublin/O=DO NOT TRUST/OU=DO NOT TRUST SERVER/CN=${ssl_hostname}"
    openssl x509 -req -in "${ssl_hostname}.csr" -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out "${ssl_hostname}.crt" -days 365 -extfile serverCertOpts
    cat "${ssl_hostname}.crt" "${ssl_hostname}.key" > "${ssl_hostname}.pem"

    # Print root CA info, as it will be needed to connect to the OM host from another machine
    echo "Root Certificate authority"
    echo "--------------------------"
    cat  rootCA.pem
    echo "--------------------------"
    echo

    # Deploy certificates to system dir
    # shellcheck disable=SC2086
    mv ${ssl_hostname}.* rootCA.* /etc/ssl/
    echo "SSL certificate deployed at:      /etc/ssl/${ssl_hostname}.pem"
    echo "ROOT CA certificate deployed at:  /etc/ssl/rootCA.pem"
    echo
    popd > /dev/null
}
ops_manager_configure_ssl() {
    if [[ "$#" -eq 0 || -z "$1" ]]; then
        ssl_hostname="$(get_public_ip)"
        echo "A hostname was not specified; defaulting to: ${ssl_hostname}"
        echo
    else
        ssl_hostname="$1"
    fi

    if [[ "${PLATFORM}" = "windows" ]]; then # Windows
        echo "Configuring SSL on Windows is not supported!"
        echo
        exit 1
    fi

    local pem_file="/etc/ssl/${ssl_hostname}.pem"
    if [ ! -f "${pem_file}" ]; then
        echo "Could not find SSL certificate at: ${pem_file}; stopping"
        echo
        exit 1
    fi

    echo "Configuring Ops Manager with SSL support..."
    echo

    (
        echo ""
        echo "# SSL settings"
        echo "mms.centralUrl=https://${ssl_hostname}:${MMS_SSL_PORT}"
        echo "mms.https.PEMKeyFile=${pem_file}"
        if [ -f /etc/ssl/rootCA.pem ]; then
            echo "mms.https.CAFile=/etc/ssl/rootCA.pem"
        fi
        echo ""
    ) | tee -a "$(_get_mms_config_file)"
}


# #######################################################
#                 MAIN Ops Manager actions
# #######################################################
ops_manager_uninstall() {
    echo "Stopping and uninstalling the Ops Manager service..."
    stop_ops_manager
    _uninstall_ops_manager
}
ops_manager_clean() {
    echo "Stopping Ops Manager, the AppDB, and the Blockstore; also deleting data dirs..."
    echo

    ops_manager_uninstall

    echo "Stopping the Ops Manager AppDB..."
    stop_mongodb "${DEFAULT_MMS_MONGODB_PORT}"

    echo "Stopping the Ops Manager blockstore..."
    stop_mongodb "${DEFAULT_MMS_BLOCKSTORE_MONGODB_PORT}"

    echo "Uninstalling MongoDB..."
    _uninstall_mongodb

    DBPATH="$(_user_dir)/${MONGOD_INSTALL_DIR}"
    echo "Removing all data from ${DBPATH}..."
    rm -rf "${DBPATH:?}"/*

    # Default TGZ install dir
    local install_dir
    install_dir="$(_get_tgz_install_dir)"
    if [ -d "${install_dir}" ]; then
        echo "Deleting ${install_dir}..."
        rm -rf "${install_dir}"
    fi

    echo "The Ops Manager environment was reset."
    echo
}
ops_manager_install_version() {
    _usage() {
        echo
        echo 'Options:'
        echo '  --version <version>           The Ops Manager version to install'
        echo '  --tgz                         Use a tar.gz instead of a pre-packaged binary'
        echo '  --mongodb-version <version>   The MongoDB version to use for AppDB'
        echo '  --central-url <uri>           Ops Manager central url'
        echo '  --ssl                         Generate and deploy an SSL certificate and configure Ops Manager to use it'
    }
    
    local version=
    local mongodb_version=
    local ip
    ip="$(get_public_ip)"
    local central_url="http://${ip}:${MMS_PORT}"
    local ssl_hostname=
    local tgz=
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --version) version="${2-}"; shift 2 ;;
            --mongodb-version) mongodb_version="${2-}"; shift 2 ;;
            --central-url) central_url="${2-}"; shift 2 ;;
            --ssl) ssl_hostname="${2-}"; shift 2 ;;
            --tgz) tgz="--tgz"; shift ;;
            * ) echo "Invalid configuration option: '$1'"; return 1 ;;
        esac
    done

    # Parameter check
    if [[ -z "${version}" ]]; then
        echo "A version was not specified!"
        _usage
        exit 1
    fi

    echo "Installing Ops Manager version: ${version}"

    echo "Searching for Ops Manager archive (version='${version}', tgz='$tgz')"
    local archive
    archive="$(_identify_installable_om_archive --version "$version" $tgz)"
    echo "Found: $archive"
    echo

    ops_manager_install_from_link --archive "$archive" \
                                  --mongodb-version "$mongodb_version" \
                                  --central-url "$central_url" \
                                  --ssl "$ssl_hostname"
}
ops_manager_install_from_link() {
    _usage() {
        echo
        echo 'Options:'
        echo '  --archive <archive>           The Ops Manager archive to download and install'
        echo '  --mongodb-version <version>   The MongoDB version to use for AppDB'
        echo '  --central-url <uri>           Ops Manager central url'
        echo '  --ssl                         Generate and deploy an SSL certificate and configure Ops Manager to use it'
    }

    local archive=
    local mongodb_version=
    local ip
    ip="$(get_public_ip)"
    local central_url="http://${ip}:${MMS_PORT}"
    local appdb_url="mongodb://127.0.0.1:${DEFAULT_MMS_MONGODB_PORT}"
    local ssl=0
    local ssl_hostname=
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --archive) archive="${2-}"; shift 2 ;;
            --mongodb-version) mongodb_version="${2-}"; shift 2 ;;
            --central-url) central_url="${2-}"; shift 2 ;;
            --ssl) ssl=1; ssl_hostname="${2-}"; shift 2 ;;
            * ) echo "Invalid configuration option: '$1'"; return 1 ;;
        esac
    done

    # Parameter check
    if [[ -z "${archive}" ]]; then
        echo "Archive was not specified!"
        _usage
        exit 1
    fi

    echo "Installing Ops Manager from: $archive"

    local upgrade=
    installed_package="$(_find_installed_package mongodb-mms)"
    if [[ -n "$installed_package" ]]; then
        echo "Found a previously installed package: $installed_package"
        echo "Performing an upgrade..."
        echo
        upgrade="--upgrade"
    else
        echo "Installing Ops Manager..."
        echo
    fi

    if [[ -z "$upgrade" ]]; then
        echo "Installing and starting the AppDB and Blockstore..."
        echo

        download_mongodb "${mongodb_version}"

        if ! is_local_port_open "${DEFAULT_MMS_MONGODB_PORT}"; then
            start_mongodb "${DEFAULT_MMS_MONGODB_PORT}"
            echo "AppDB started!"
            echo
        fi

        if ! is_local_port_open "${DEFAULT_MMS_BLOCKSTORE_MONGODB_PORT}"; then
            start_mongodb "${DEFAULT_MMS_BLOCKSTORE_MONGODB_PORT}"
            echo "Blockstore started!"
            echo
        fi

        echo "The AppDB and Blockstore are running!"
        echo
    fi

    _download_ops_manager "$archive"

    if [[ "$upgrade" = "--upgrade" ]]; then
        echo "This is an upgrade. Stopping any running Ops Manager services before proceeding with the install..."
        echo
        stop_ops_manager
    fi

    _install_ops_manager --archive "$archive" $upgrade

    local extra_options=
    local extra_start_options=
    if _is_tgz "${archive}"; then
        extra_options="--install-dir $(_get_tgz_install_dir)"
        extra_start_options="--skip-waiting-for-daemon"
    fi
    #shellcheck disable=SC2086
    _configure_ops_manager --skip-registration-wizard \
                          --central-url "${central_url}" \
                          --appdb-url "${appdb_url}" \
                          ${extra_options}

    # Configure SSL
    if [[ "${ssl}" -eq 1 && -n "${ssl_hostname}" ]]; then
        echo "Configuring Ops Manager with SSL for host ${ssl_hostname}..."
        echo
        ssl_generate_server_certificate "${ssl_hostname}"
        ops_manager_configure_ssl "${ssl_hostname}"
    fi

    # Start the service
    start_ops_manager --archive "$archive" ${extra_start_options}
}

# TODO: continue reviewing from here

# #######################################################
#             SEED THE TARGET ENVIRONMENT
# #######################################################
run() {
    # Print usage info
    if [[ "$#" -lt 2 ]]; then
        echo "Usage: run user@hostname [args...]"
        echo
        exit 1
    fi

    # Determine args
    host=$1
    shift
    args=$*

    echo "Running remote command '${args}' on ${host}..."

    # shellcheck disable=SC2086
    "$SSH" -tt -A "${ssh_opts[@]}" ${SSH_OPTS-} "${host}" $args
}
run-background() {
    # Print usage info
    if [[ "$#" -lt 2 ]]; then
        echo "Usage: run-background user@hostname [args...]"
        echo
        exit 1
    fi

    # Determine args
    host=$1
    shift
    args=$*

    echo "Running remote command (run-background) '${args}' on ${host}..."

    DT="$(date +%Y%m%d%H%M%S)"
    echo "Renaming artifacts generated in previous runs (*.$DT)"
    # shellcheck disable=SC2086
    "$SSH" -tt "${ssh_opts[@]}" ${SSH_OPTS-} "${host}" "if [ -e ${NOHUP_PROV_FILE}.out ]; then mv ${NOHUP_PROV_FILE}.out ${NOHUP_PROV_FILE}.out.$DT; fi; \
        if [ -e ${NOHUP_PROV_FILE} ]; then mv ${NOHUP_PROV_FILE} ${NOHUP_PROV_FILE}.$DT; fi"

    # Create a provisioning script, then upload it to the host
    PROV=$(mktemp)
    echo "#!/usr/bin/env bash" > "$PROV" # Create a new file
    chmod 0775 "$PROV"                   # Allow a+rx
    # shellcheck disable=SC2129
    echo "echo \"Started at: \$(date)\"" >> "$PROV" # Print start date
    echo "$args" >> "$PROV"              # Run command
    echo "exit_code=\$?" >> "$PROV"      # Capture exit code
    echo "printf \$exit_code >> ${NOHUP_PROV_FILE}.out" >> "$PROV" # Save exit code
    echo "echo \"Finished at: \$(date)\"" >> "$PROV" # Print completion date
    echo "echo \"Exit code: \$exit_code\"" >> "$PROV" # And output the exit code

    echo "Uploading provisioning script to ${host}:${NOHUP_PROV_FILE}..."
    # shellcheck disable=SC2016,SC2086
    _scp "${PROV}" "${host}:${NOHUP_PROV_FILE}"

    echo "Executing provisioning script..."
    # shellcheck disable=SC2086
    "$SSH" -tt "${ssh_opts[@]}" ${SSH_OPTS-} "${host}" nohup bash -c './'${NOHUP_PROV_FILE}' > '${NOHUP_LOG_FILE}' 2>&1' &
    echo "Remote command (run-background) was executed on ${host}..."
    echo "${args}"
    echo
}
tail() {
    # Print usage info
    if [[ "$#" -lt 1 ]]; then
        echo "Usage: tail user@hostname"
        echo
        exit 1
    fi

    # Determine args
    host=$1

    echo "Tailing ${NOHUP_LOG_FILE} from ${host}..."
    # shellcheck disable=SC2086
    "$SSH" -tt "${ssh_opts[@]}" ${SSH_OPTS-} "${host}" "while [ ! -e \"${NOHUP_LOG_FILE}\" ]; do sleep 1; done; tail -n 500 -F \"${NOHUP_LOG_FILE}\" | while IFS= read line; do echo \$line; [ -e \"${NOHUP_PROV_FILE}.out\" ] && pkill tail; done"
    echo "Stopped tailing ${NOHUP_LOG_FILE} on ${host}..."
}
_scp() {
    # Print usage info
    if [[ "$#" -lt 2 ]]; then
        echo "Usage: _scp <source> <destination>"
        echo
        exit 1
    fi

    # shellcheck disable=SC2016,SC2086
    if ! scp "${ssh_opts[@]}" ${SSH_OPTS-} "$1" "$2"; then
        # Retry once, with increased verbosity
        # shellcheck disable=SC2016,SC2086
        scp -vvv "${ssh_opts[@]}" ${SSH_OPTS-} "$1" "$2"
    fi
}
seed-local() {
    #shellcheck disable=SC2016
    WORKDIR='$HOME'
    if [[ "$#" -gt 0 && -n "$1" ]]; then
        WORKDIR="$1"
    fi

    echo "Installing ego to ${WORKDIR}"
    mkdir -p "${WORKDIR}/.ego/bin"
    cp "${DIR}/${SCRIPT}" "${WORKDIR}/.ego/bin/"
    chmod a+x "${WORKDIR}/.ego/bin/${SCRIPT}"
    "${WORKDIR}/.ego/bin/${SCRIPT}" link
    "${WORKDIR}/.ego/bin/${SCRIPT}" resolve_system_dependencies
    "${WORKDIR}/.ego/bin/${SCRIPT}" iptables_default_http_redirect
    "${WORKDIR}/.ego/bin/${SCRIPT}" ulimits
}
seed() {
    # Print usage info
    if [[ "$#" -lt 1 ]]; then
        echo "Usage: seed user@hostname [WORKDIR]"
        echo
        exit 1
    fi

    echo "Deploying '${SCRIPT}' to '$1'..."
    _scp "${DIR}/${SCRIPT}" "$1:"

    #shellcheck disable=SC2016
    local WORKDIR='$HOME'
    if [[ "$#" -gt 1 && -n "$2" ]]; then
        WORKDIR="$2"
    fi

    declare -a remote_exec_cmd=()
    remote_exec_cmd+=("mkdir -p ${WORKDIR}/.ego/bin;")
    remote_exec_cmd+=("cp ${SCRIPT} ${WORKDIR}/.ego/bin/;")
    remote_exec_cmd+=("chmod a+x ${WORKDIR}/.ego/bin/${SCRIPT};")
    remote_exec_cmd+=("${WORKDIR}/.ego/bin/${SCRIPT} link;")
    remote_exec_cmd+=("${WORKDIR}/.ego/bin/${SCRIPT} resolve_system_dependencies;")
    remote_exec_cmd+=("${WORKDIR}/.ego/bin/${SCRIPT} iptables_default_http_redirect;")
    remote_exec_cmd+=("${WORKDIR}/.ego/bin/${SCRIPT} ulimits;")

    # shellcheck disable=SC2016,SC2086
    if ! "$SSH" -tt "${ssh_opts[@]}" ${SSH_OPTS-} "$1" ${remote_exec_cmd[*]}; then
        # Retry once, with increased verbosity

        # shellcheck disable=SC2016,SC2086
        "$SSH" -vvv -tt "${ssh_opts[@]}" ${SSH_OPTS-} "$1" ${remote_exec_cmd[*]}
    fi
    echo
    echo "Deployed ${SCRIPT} to $1..."
}
ssh() {
    # Parameter check
    if [[ "$#" -lt 1 ]]; then
        echo "Invalid call 'ssh $*'"
        echo "Usage: ssh user@hostname"
        echo
        exit 1
    fi

    # Connects to remote host
    echo "Connecting to $1..."
    # shellcheck disable=SC2086
    if ! "$SSH" -tt -A "${ssh_opts[@]}" ${SSH_OPTS-} "$1" /bin/bash; then
        # Retry once, with increased verbosity
        "$SSH" -vvv -tt -A "${ssh_opts[@]}" ${SSH_OPTS-} "$1" /bin/bash
    fi
}

# #######################################################
#                           MAIN
# #######################################################
_available_functions() {
    declare -F | awk '{print $3}' | grep -vE '^_'
}
_usage() {
    echo "Usage: ${0} FUNCTION"
    echo
    echo "Available functions:"
    echo "------------------"
    for func in $(_available_functions); do echo "$func"; done
    echo "------------------"
    echo
    exit 1
}

main() {
    # If no parameters were specified, print the usage help
    if [[ "$#" -eq 0 ]]; then
        _usage
    fi

    # Run as super user, unless the functions do not require it, or the script is run without any parameters
    _determine_architecture
    if [[ ${NON_ROOT_FUNCTIONS} != *"$1"* ]]; then
        [[ "$UID" -eq 0 || "${PLATFORM}" = "windows" ]] || exec sudo -SE "$0" "$@"
    fi

    # Limit the scope of this script to functions defined in it
    #if ! grep -qE "\\b$1\\b" <<< "${AVAILABLE_FUNCTIONS}"; then
    if ! grep -qE "\\b$1\\b" <<< "$(_available_functions)"; then
        echo "Function not defined: '$1'!"
        echo

        # Attempt to match the passed name to the list of available functions
        if [[ $(_available_functions) = *"$1"* ]]; then
            echo "Did you mean?"
            echo "------------------"
            for func in $(_available_functions); do
                if [[ "${func/$1}" != "${func}" ]] ; then
                    echo "${func}"
                fi
            done
            echo "------------------"
            echo
            exit 1

        # Otherwise print the whole list
        else
            _usage
        fi
    fi

    # Set a TERM var if not already in the env
    _fix_term

    echo
    echo "------------------"
    echo "Executing: ${SCRIPT} $*"
    echo "------------------"
    echo
    "$@"
}

main "$@"