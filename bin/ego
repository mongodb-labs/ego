#!/usr/bin/env bash

set -o nounset
set -o errexit

# Naming convention:
# - public_function: these can be executed via "ego public_function param1 [param2] ..."
# - _private_function: these cannot be called via the CLI
#
# Main logic:
# These are probably the more useful abstractions, since they can be used to quickly set-up a new host and execute a desired
# flow to either confirm that the E2E tests can be run against a custom build, or to simply provision a custom environment.
# - ops_manager_install_version: Installs the specified Ops Manager Version, then starts it
#                                on Linux, SSL can also be configured
# - ops_manager_install_from_link: Download and install the given Ops Manager package

# - ops_manager_clean: Reset the environment to resemble a fresh Ops Manager install (delete AppDb and Blockstore data dir)
# - ops_manager_start_from_tgz: Given an Ops Manager tgz, extract the files and start the service with the current user account
#
# Other features:
# - run: executes the specified command on a remote host via SSH and pipes all output to stdout
# - nohup: similar to run, but launches a background process via SSH, then disconnects
# - tail: follow logs generated by the 'ego nohup' command
# - system_info: print information about the current running system
# - resolve_system_dependencies: install all required system dependencies required to run Ops Manager
#                               (package and source-code) (Linux-only)
# - _determine_architecture: detect running distribution and stop execution if not supported
# - get_host_ip/aws_get_local_ip/aws_get_public_ip: retrieve the running host's private/public IP
#                                                   (in AWS using the Metadata endpoint)
# - service_command: start/stop/restart services (automatically choosing SystemD, SysV, and init.d scripts)
# - is_local_port_open: detect if a specified port is open
# - wait_for_open_local_port/wait_for_closed_local_port: wait until the specified port is open/closed on 127.0.0.1
# - wait_for_open_port/wait_for_closed_port: wait until the port is open/closed on the specified host
# - wait_for_mms_service_to_exit: wait until the mms service reaches an exit state
# - replace_property_in_file: replace (or define) a key=value in a property file
# - _install_test_dependencies/install_*: install various dependencies: chrome_driver, chrome, nodejs, ant, jdk, docker
# - download_mongodb/start_mongodb: download MongoDB, install it, and start or stop it (all platforms)
# - start_ops_manager/stop_ops_manager/restart_ops_manager: start/stop/restart ops manager (all platforms)
# - network_access_restrict: restrict access to/from the current host (Linux-only, iptables) - useful for Local Mode testing
# - configure_proxy: configure an HTTP proxy (Linux-only, squid) - useful for Ops Manager HTTP proxy configuration testing
# - ssl_generate_server_certificate: generate Root CA and SSL certificates for a specified host - useful for Ops Manager with SSL testing
# - ops_manager_configure_ssl: configure Ops Manager to start with SSL-enabled (Linux only)
#
# NOTE: Not all actions can be performed in all systems, due to various incompatibilities.
#       Wherever this is the case, the script will alert you and in some cases stop execution altogether.
#

readonly DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
readonly SCRIPT=$(basename "${BASH_SOURCE[0]}")
readonly NON_ROOT_FUNCTIONS="_set_mongod_vars aws_get_local_ip aws_get_public_ip download_logs get_app_setting get_host_ip get_om_port get_om_scheme is_local_port_open is_upgrade_mode_enabled nohup run seed ssh system_info tail wait_for_closed_local_port wait_for_open_local_port wait_for_open_port"

# Other settings
declare -a curl_opts
curl_opts[0]="--silent"
curl_opts[1]="--show-error"
curl_opts[2]="--fail"
curl_opts[3]="--location"
curl_opts[4]="--retry"
curl_opts[5]="3"
curl_opts[6]="--create-dirs"
readonly curl_opts
declare -a ssh_opts
ssh_opts[0]="-o"
ssh_opts[1]="UserKnownHostsFile=/dev/null"
ssh_opts[2]="-o"
ssh_opts[3]="StrictHostKeyChecking=no"
ssh_opts[4]="-q"
ssh_opts[5]="-o"
ssh_opts[6]="ConnectTimeout=30"
ssh_opts[7]="-o"
ssh_opts[8]="TCPKeepAlive=yes"
ssh_opts[9]="-o"
ssh_opts[10]="ServerAliveInterval=15"
ssh_opts[11]="-o"
ssh_opts[12]="ServerAliveCountMax=20"
#ssh_opts[13]="-vvv" # DEBUG mode
readonly ssh_opts
readonly timeout_duration="15m"
declare -ri DEFAULT_MMS_MONGODB_PORT=27017
declare -ri DEFAULT_MMS_BLOCKSTORE_MONGODB_PORT=27018
readonly JQ_VERSION="1.6"
readonly DEFAULT_MMS_DIR="/opt/mongodb/mms"
readonly MONGOD_INSTALL_DIR="data"
readonly NOHUP_LOG_FILE="ego.log"
readonly NOHUP_PROV_FILE="provision.bash"
declare -i MMS_PORT=9080
declare -i MMS_SSL_PORT=9443
declare -ri MMS_DAEMON_PORT=8087
declare -ri PROXY_PORT=8888

# Commands
LSB_RELEASE="$(command -v lsb_release || echo "lsb_release")"
NC="$(command -v nc || echo "nc")"
SCP="$(command -v scp || echo "scp")"
SERVICE="$(command -v service || echo "service")"
SSH="$(command -v ssh || echo "ssh")"
TIMEOUT="$(command -v timeout || echo "timeout")"
UNAME="$(command -v uname || echo "uname")"

_mark_versions_set() {
    export INSTALL_VERSION="$1"
}
_are_versions_set() {
    if [[ -z "${INSTALL_VERSION+x}" ]]; then
        return 1
    fi
    return 0
}
_fix_term() {
    # Set a TERM env var
    if [[ -z "${TERM+x}" ]]; then
      export TERM=xterm
    fi

    # Do not allow Debian distros to have an interactive term
    if [[ "${PLATFORM}" = "debian" || "${PLATFORM}" = "ubuntu" ]]; then
      export DEBIAN_FRONTEND="noninteractive"
    fi
}
export CONFIGDB_MDB_VERSION=4.2.1

# #######################################################
#                   SYSTEM DEPENDENCIES
# #######################################################
readonly E_UNSUPPORTED_DISTRO=145
_unsupported_distro() {
    echo "Unsupported distro..."
    if "$UNAME" > /dev/null 2>&1; then
        echo
        echo "uname:"
        uname -a
    fi
    if "$LSB_RELEASE" > /dev/null 2>&1; then
        echo
        echo "lsb_release:"
        "$LSB_RELEASE" -a
    fi
    if [[ -f /etc/SuSe-release ]]; then
        echo
        echo "/etc/SuSe-release:"
        cat /etc/SuSE-release
    fi
    if [[ -f /etc/os-release ]]; then
        echo
        echo "/etc/os-release:"
        cat /etc/os-release
    fi
    exit ${E_UNSUPPORTED_DISTRO}
}
system_info() {
    echo
    echo "System information"
    echo "---------------------"
    echo "Platform: ${PLATFORM}"
    if [[ "${OSVER}" != -1 ]]; then
        echo "OS version: ${OSVER}"
    fi
    echo "MongoDB architecture: ${MDB_ARCH}"
    echo "---------------------"
    echo
}
# Determine architecture and version
_determine_architecture() {
    PLATFORM=""
    OSVER=-1
    MDB_ARCH=""
    if [[ -n ${OS+x} && "Windows_NT" = "${OS}" ]]; then
        PLATFORM="windows"
        MDB_ARCH="x86_64-2008plus-ssl"

    elif uname -a | grep -q Debian > /dev/null 2>&1; then # Debian
        PLATFORM="debian"
        if grep -qE '^10' /etc/debian_version; then
            OSVER=10
            MDB_ARCH="x86_64-debian10"

        elif grep -qE '^9' /etc/debian_version; then
            OSVER=9
            MDB_ARCH="x86_64-debian92"

        elif grep -qE '^8' /etc/debian_version; then
            OSVER=8
            MDB_ARCH="x86_64-debian81"

        else
            _unsupported_distro
        fi

    elif uname -a | grep -q Ubuntu > /dev/null 2>&1; then # Ubuntu
        PLATFORM="ubuntu"
        if "$LSB_RELEASE" -a 2>&1 | grep 18.04 > /dev/null 2>&1; then
            OSVER=18
            MDB_ARCH="x86_64-ubuntu1804"

        elif "$LSB_RELEASE" -a 2>&1 | grep 16.04 > /dev/null 2>&1; then
            OSVER=16
            MDB_ARCH="x86_64-ubuntu1604"

        else
            _unsupported_distro
        fi

    elif uname -a | grep -q Darwin; then # Darwin/MacOS
        PLATFORM="macos"
        MDB_ARCH="ssl-x86_64"

    elif "$LSB_RELEASE" -a 2>&1 | grep -qE "^Description:\\s+Red Hat.+ 8" > /dev/null; then # Red Hat 8
        PLATFORM="rhel"
        OSVER="8"
        MDB_ARCH="x86_64-rhel80"

    elif "$LSB_RELEASE" -a 2>&1 | grep -qE "^Description:\\s+Red Hat.+ 7" > /dev/null; then # Red Hat 7
        PLATFORM="rhel"
        OSVER="7"
        MDB_ARCH="x86_64-rhel70"

    elif [[ -f /etc/os-release ]] && grep PRETTY /etc/os-release | grep -qE 'Red Hat.+ 8' > /dev/null; then # Red Hat 8
        PLATFORM="rhel"
        OSVER="8"
        MDB_ARCH="x86_64-rhel80"

    elif [[ -f /etc/os-release ]] && grep PRETTY /etc/os-release | grep -qE 'Red Hat.+ 7' > /dev/null; then # Red Hat 7
        PLATFORM="rhel"
        OSVER="7"
        MDB_ARCH="x86_64-rhel70"

    elif [[ -f /etc/system-release ]] && grep -qE 'Red Hat.+ 8' /etc/system-release > /dev/null; then # Red Hat 8
        PLATFORM="rhel"
        OSVER="8"
        MDB_ARCH="x86_64-rhel80"

    elif [[ -f /etc/system-release ]] && grep -qE 'Red Hat.+ 7' /etc/system-release > /dev/null; then # Red Hat 7
        PLATFORM="rhel"
        OSVER="7"
        MDB_ARCH="x86_64-rhel70"

    elif "$LSB_RELEASE" -a 2>&1 | grep -qE "^Description:\\s+Red Hat.+ 6" > /dev/null; then
        PLATFORM="rhel"
        OSVER="6"
        MDB_ARCH="x86_64-rhel62"

    elif [[ -f /etc/os-release ]] && grep PRETTY /etc/os-release | grep -qE 'Red Hat.+ 6' > /dev/null; then # Red Hat 6
        PLATFORM="rhel"
        OSVER="6"
        MDB_ARCH="x86_64-rhel62"

    elif [[ -f /etc/system-release ]] && grep -qE 'Red Hat.+ 6' /etc/system-release > /dev/null; then # Red Hat 6
        PLATFORM="rhel"
        OSVER="6"
        MDB_ARCH="x86_64-rhel62"

    elif [[ -f /etc/os-release ]] && grep PRETTY /etc/os-release | grep -qE 'SUSE.+15' > /dev/null; then # SUSE 15
        PLATFORM="suse"
        OSVER=15
        MDB_ARCH="x86_64-suse15"

    elif [[ -f /etc/SuSE-release ]] && grep -q SUSE /etc/SuSE-release > /dev/null; then # SUSE
        PLATFORM="suse"
        if grep VERSION /etc/SuSE-release | grep -q 12 > /dev/null; then # SUSE 12
            OSVER=12
            MDB_ARCH="x86_64-suse12"

        elif grep VERSION /etc/SuSE-release | grep -q 15 > /dev/null; then # SUSE 15
            OSVER=15
            MDB_ARCH="x86_64-suse15"

        else
            _unsupported_distro
        fi

    elif [[ -f /etc/issue ]] && grep -qE 'SUSE.+ 12' /etc/issue > /dev/null; then # SUSE 12
        PLATFORM="suse"
        OSVER=12
        MDB_ARCH="x86_64-suse12"

    elif [[ -f /etc/issue ]] && grep -qE 'SUSE.+ 15' /etc/issue > /dev/null; then # SUSE 15
        PLATFORM="suse"
        OSVER=15
        MDB_ARCH="x86_64-suse15"

    elif [[ -f /etc/os-release ]] && grep PRETTY /etc/os-release | grep -q 'Amazon Linux 2' > /dev/null; then # Amazon Linux 2
        PLATFORM="amazon"
        OSVER=2
        MDB_ARCH="x86_64-amazon2"

    elif uname -a | grep -q 'Microsoft'; then # Microsoft Windows Subsystem for Linux
        PLATFORM="wsl"
        MDB_ARCH="-unsupported-mongodb-install-"

    else
        _unsupported_distro
    fi

    # Declare vars are readonly
    readonly PLATFORM
    readonly OSVER
    readonly MDB_ARCH

    # Print platform details
    system_info
}


# #######################################################
#                        HELPERS
# #######################################################
get_host_ip() {
    /sbin/ifconfig | grep -E 'inet[^0-9]+' | sed -re 's/.*inet[^0-9]+([0-9\.]+).*/\1/g' | grep -v 127.0.0.1
}
aws_get_local_ip() {
    _curl http://169.254.169.254/latest/meta-data/local-ipv4
}
aws_get_local_hostname() {
    _curl http://169.254.169.254/latest/meta-data/local-hostname
}
aws_get_public_ip() {
    _curl --silent http://169.254.169.254/latest/meta-data/public-ipv4
}
service_command() {
    # Parameter check
    if [[ "$#" -lt 2 ]]; then
        echo "Invalid call 'service_command $*'"
        echo "Usage: service_command COMMAND SERVICE_NAME"
        echo
        exit 1
    fi

    COMMAND="$1"
    SERVICE_NAME="$2"
    if proc="$(ps -o comm 1)"; test "${proc#*systemd}" != "$proc"; then
        echo "[SystemD] ${COMMAND} ${SERVICE_NAME}"

       # always give the untruncated status, and do not print the status twice if service_command status is called.
        if [[ "${COMMAND}" = "status" ]] ; then
            systemctl --no-pager status -l "${SERVICE_NAME}.service"
        else
            systemctl --no-pager "${COMMAND}" "${SERVICE_NAME}.service"
            systemctl --no-pager status -l "${SERVICE_NAME}.service"
        fi

    elif "$SERVICE" > /dev/null 2>&1; then
        echo "[SysV] ${COMMAND} ${SERVICE_NAME}"
        service "${SERVICE_NAME}" "${COMMAND}"

        if [[ "${COMMAND}" != "status" ]] ; then
            service "${SERVICE_NAME}" status
        fi

    elif [ -f "/etc/init.d/${SERVICE_NAME}" ]; then
        echo "Executing /etc/init.d/${SERVICE_NAME} ${COMMAND}"
        "/etc/init.d/${SERVICE_NAME}" "${COMMAND}"

        if [[ "${COMMAND}" != "status" ]] ; then
            "/etc/init.d/${SERVICE_NAME}" status
        fi
        
    else
        echo "Nothing to do for service ${SERVICE_NAME} ${COMMAND}"
        echo
    fi
}
is_local_port_open() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A port was not supplied!"
        echo "Usage: is_local_port_open PORT"
        echo
        exit 1
    fi

    # Attempt to use netcat, or otherwise resort to bash timeouts and /dev/tcp
    if [ -e "$NC" ]; then
        if "$NC" -w 1 127.0.0.1 "$1" </dev/null >/dev/null 2>&1; then
            echo "Port $1 is open!"
            return 0
        fi
    else
        if "$TIMEOUT" 1s bash -c "cat < /dev/null > /dev/tcp/127.0.0.1/$1" > /dev/null 2>&1; then
            echo "Port $1 is open!"
            return 0
        fi
    fi

    # Return error status if port is not open
    echo "Port $1 is closed!"
    return 1
}
wait_for_open_port() {
    # Parameter check
    if [[ "$#" -lt 2 ]]; then
        echo "Host/port were not supplied!"
        echo "Usage: wait_for_open_port HOST PORT"
        echo
        exit 1
    fi

    echo "Waiting for ${timeout_duration} for port $1:$2 to open..."
    FLAG=""
    if "$TIMEOUT" --foreground 1s echo > /dev/null 2>&1; then
        FLAG="--foreground"
    fi

    if [ -e "$NC" ]; then
        "$TIMEOUT" ${FLAG} ${timeout_duration} bash -c 'while ! '"$NC"' -w 1 '"$1"' '"$2"' </dev/null >/dev/null 2>&1; do printf .; sleep 5; done'
    else
        "$TIMEOUT" ${FLAG} ${timeout_duration} bash -c 'while ! '"$TIMEOUT"' '${FLAG}' 1s bash -c "cat < /dev/null > /dev/tcp/'"$1"'/'"$2"'" > /dev/null 2>&1; do printf .; sleep 5; done'
    fi
    echo "Port $1:$2 is open!"
}
wait_for_open_local_port() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A port was not supplied!"
        echo "Usage: wait_for_open_local_port PORT"
        echo
        exit 1
    fi

    wait_for_open_port 127.0.0.1 "$1"
}
wait_for_closed_port() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "Host/port were not supplied!"
        echo "Usage: wait_for_closed_port PORT"
        echo
        exit 1
    fi

    echo "Waiting for ${timeout_duration} for port $1:$2 to close..."
    FLAG=""
    if "$TIMEOUT" --foreground 1s echo > /dev/null 2>&1; then
        FLAG="--foreground"
    fi
    if [ -e "$NC" ]; then
        "$TIMEOUT" ${FLAG} ${timeout_duration} bash -c 'while '"$NC"' -w 1 '"$1"' '"$2"' </dev/null >/dev/null 2>&1; do printf .; sleep 5; done'
    else
        "$TIMEOUT" ${FLAG} ${timeout_duration} bash -c 'while '"$TIMEOUT"' '${FLAG}' 1s bash -c "cat < /dev/null > /dev/tcp/'"$1"'/'"$1"'" > /dev/null 2>&1; do printf .; sleep 5; done'
    fi
    echo "Port $1:$2 is closed!"
}
wait_for_closed_local_port() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A port was not supplied!"
        echo "Usage: wait_for_closed_local_port PORT"
        echo
        exit 1
    fi

    wait_for_closed_port 127.0.0.1 "$1"
}
replace_property_in_file() {
    # Parameter check
    if [[ "$#" -lt 3 ]]; then
        echo "Invalid call: 'replace_property_in_file $*'"
        echo "Usage: replace_property_in_file FILENAME PROPERTY VALUE"
        echo
        exit 1
    fi

    # Set the new property
    temp_file=$(mktemp)
    grep -vE "^\\s*${2}\\s*=" "${1}" > "${temp_file}" # Export contents minus any lines containing the specified property
    echo "${2}=${3}" >> "${temp_file}"                # Set the new property value
    cat "${temp_file}" > "${1}"                       # Replace the contents of the original file, while preserving any permissions
    rm "${temp_file}"
}

# #######################################################
#                SYSTEM/TEST DEPENDENCIES
# #######################################################

DEPS="unzip curl jq squid openssl nc xdg-utils libxss1 libappindicator1 libindicator7 fonts-liberation libappindicator3-1 libdbusmenu-gtk3-4 libssl1.0-dev"
_wait_for_process_to_finish() {
    echo "Waiting for ${timeout_duration} for $1 to complete any running jobs..."

    "$TIMEOUT" ${timeout_duration} bash -c 'while pgrep '"$1"' > /dev/null 2>&1; do printf .; sleep 5; done'
}
_ensure_tmp_dir_is_writeable() {
    # Attempt to set the appropriate perms, but continue if any of the operations fail
    set +e
    for d in /tmp /var/tmp /data/tmp; do
        echo "Ensure $d is writeable..."
        chmod -R 0777 "$d"
    done
    set -e
}
_install_dep() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "An package name was not specified!"
        echo "Usage: _install_dep PACKAGE_NAME"
        echo
        exit 1
    fi

    if [[ "${PLATFORM}" = "debian" ]] || [[ ${PLATFORM} = "ubuntu" ]]; then # Debian/Ubuntu
        set +o errexit
        apt-get install -y -q "$1"
        set -o errexit

    elif [[ "${PLATFORM}" = "rhel" ]] || [[ ${PLATFORM} = "amazon" ]]; then # Red Hat / Amazon Linux
        set +o errexit
        yum install -y -q "$1"
        set -o errexit

    elif [[ "${PLATFORM}" = "suse" ]]; then # SuSe
        set +o errexit
        zypper -n -q install --details -- "$1"
        set -o errexit

    else
        echo "Could not install $1. Unsupported package manager or distribution!"
        echo
        _unsupported_distro
    fi
}
resolve_system_dependencies() {
    _ensure_tmp_dir_is_writeable

    # Update host system
    if [[ "${PLATFORM}" = "debian" ]] || [[ "${PLATFORM}" = "ubuntu" ]]; then # Debian/Ubuntu
        _wait_for_process_to_finish apt
        _wait_for_process_to_finish dpkg
        #apt-get update -y
        #_wait_for_process_to_finish apt
        #_wait_for_process_to_finish dpkg

    elif [[ "${PLATFORM}" = "rhel" ]] || [[ "${PLATFORM}" = "amazon" ]]; then # Red Hat / Amazon Linux
        _wait_for_process_to_finish yum
        #yum update -y --skip-broken

    elif [[ "${PLATFORM}" = "suse" ]]; then # SuSe
        _wait_for_process_to_finish zypper
        #zypper -n update --details

    elif [[ "${PLATFORM}" = "windows" ]]; then # Windows
        echo "Cannot update System Dependencies in Cygwin..."
        echo

        echo "Installing JQ"
        pushd "$(_user_dir)" > /dev/null
        _curl "${curl_opts}" -o "jq.exe" "https://github.com/stedolan/jq/releases/download/jq-${JQ_VERSION}/jq-win64.exe"
        popd > /dev/null

        return
    fi

    # Install dependencies individually
    for dep in ${DEPS}; do
        _install_dep "${dep}"
    done
}
_user_dir() {
    if [[ -n ${SUDO_USER+x} ]]; then
         # If executing through sudo, retrieve the calling user's dir
        eval echo "~${SUDO_USER}"
    else
        # Otherwise use the home dir
        echo "${HOME}"
    fi
}
_curl() {
    $(command -v curl || echo "curl") "$@"
}
link() {
    echo "Linking EGO in the system path..."
    # Link the script to make it available for running
    for p in /usr/local/bin /usr/bin; do
        if echo "$PATH" | grep -q "$p"; then
            ln -sf "${DIR}/${SCRIPT}" "$p"
        fi
    done
    echo "Linked."
}
_set_mongod_vars() {
    if [[ "${PLATFORM}" = "windows" ]]; then # Cygwin
        MONGOD="$(_user_dir)/mongodb/bin/mongod.exe"
        MONGO="$(_user_dir)/mongodb/bin/mongo.exe"
    elif [[ "${PLATFORM}" == "wsl" ]]; then # WSL
        MONGOD="$(command -v mongod)"
        MONGO="$(command -v mongo)"
    else # Standard Linux x86_64
        MONGOD="$(_user_dir)/mongodb/bin/mongod"
        MONGO="$(_user_dir)/mongodb/bin/mongo"
    fi
}

# #######################################################
#                        MONGODB
# #######################################################
_mongodb_archive_name() {
    mdb_arch="${MDB_ARCH}"
    version=$1

    if echo "$1" | grep -q "ent"; then
        # for enterprise versions, the url will look like "mongodb-linux-x86_64-enterprise-rhel57.tgz"
        # So if our desired version input ends in '-ent', add -enterprise to the arch string,
        # then get the version string without '-ent'
        # Note this won't work on PowerPC
        mdb_arch="${mdb_arch//x86_64/x86_64-enterprise}"
        version="${version//-ent/}"
    fi

    if [[ "${PLATFORM}" = "windows" ]]; then
        echo "mongodb-win32-${mdb_arch}-$version.zip"
    else
        echo "mongodb-linux-${mdb_arch}-$version.tgz"
    fi
}
download_mongodb() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A version was not supplied!"
        echo "Usage: download_mongodb VERSION"
        echo
        exit 1
    fi

    if [[ -d "$(_user_dir)/mongodb" ]]; then
        echo "MongoDB already present on the host system, skipping..."
        echo
        return
    fi

    root_download_url="https://fastdl.mongodb.org"
    if echo "$1" | grep -q "ent"; then
        root_download_url="https://downloads.mongodb.com"
    fi

    file_name=$(_mongodb_archive_name "$1")
    pushd "$(_user_dir)" > /dev/null
    if [[ "${PLATFORM}" = "windows" ]]; then
        archive="${root_download_url}/win32/${file_name}"
        echo "Downloading ${archive}..."
        _curl "${curl_opts}" -o "${file_name}" "${archive}"
        unzip "${file_name}" > /dev/null
    else
        archive="${root_download_url}/linux/${file_name}"
        echo "Downloading ${archive}..."
        _curl "${curl_opts[@]}" -o "${file_name}" "${archive}"
        tar zxf "${file_name}"
    fi

    local final_dir
    final_dir="$(_user_dir)"/mongodb

    # Move database to final location
    rm -f "${file_name}"
    mdb_dir="${file_name%.*}"
    mv "${mdb_dir}" "${final_dir}"
    echo "Downloaded ${archive} and deployed at ${final_dir}..."

    # For enterprise builds, install the Visual Studio redistributable
    if [[ "${PLATFORM}" = "windows" ]] && echo "${file_name}" | grep -q "enterprise"; then
        echo "Installing VC redist for MongoDB..."
        chmod +x "${final_dir}/vcredist_x64.exe"
        "${final_dir}/vcredist_x64.exe" /quiet /norestart || echo "VC redist might already be installed..."
    fi

    # Set perms
    chmod +x "${final_dir}"/bin/*

    popd > /dev/null
}
_uninstall_mongodb() {
    if [ ! -d "$(_user_dir)"/mongodb ]; then
        echo "MongoDB is not present on the host system, skipping..."
        echo
        return
    fi

    echo "Removing MongoDB from host system"
    echo
    rm -rf "$(_user_dir)"/mongodb
}

# #######################################################
#                 START MONGODB INSTANCE
# #######################################################
start_mongodb() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A port was not supplied!"
        echo "Usage: start_mongodb PORT [BIND_IP/'bind_ip_all'] [OPTIONS]"
        echo
        exit 1
    fi

    port=$1
    shift

    local bind_ip="127.0.0.1"
    if [[ "$#" -gt 0 ]]; then
        bind_ip=$1
        shift
    fi

    local bind_ip_option="--bind_ip ${bind_ip}"
    if [[ "${bind_ip}" == "bind_ip_all" ]]; then
        bind_ip="0.0.0.0"
        bind_ip_option="--bind_ip_all"
    fi

    _set_mongod_vars

    if "${MONGO}" --port "${port}" --eval "db.hostInfo()" > /dev/null 2>&1; then
        echo "Found previously running MongoD on ${port}; skipping start..."
        return
    fi

    # Create data dir
    mkdir -p "$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}"

    # Ensure that the log file is readable/writeable by any user
    touch "$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}/mongod.log"
    chmod 0777 "$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}/mongod.log"

    # Start Mongod
    echo "Starting MongoDB on ${port}, binding on ${bind_ip}..."
    extra_options="$*"
    if [[ "${PLATFORM}" = "windows" ]]; then
        # dbpath must be in Windows formatting for mongod to find it (it won't be resolved in cygwin)
        dbpath=$(cygpath --windows "$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}")
        logfile=$(cygpath --windows "$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}/mongod.log")

        # shellcheck disable=SC2086
        screen -fn -d -m "${MONGOD}" --port "${port}" \
                                     --logpath="${logfile}" \
                                     --logappend \
                                     --dbpath="${dbpath}" \
                                     --storageEngine=wiredTiger \
                                     --wiredTigerCacheSizeGB 0.5 \
                                     ${bind_ip_option} \
                                     --oplogSize=100 \
                                     ${extra_options};
    else
        # shellcheck disable=SC2086
        "${MONGOD}" --port "${port}" \
                    --logpath="$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}/mongod.log" \
                    --logappend \
                    --dbpath="$(_user_dir)/${MONGOD_INSTALL_DIR}/${port}" \
                    --storageEngine=wiredTiger \
                    --wiredTigerCacheSizeGB 0.5 \
                    ${bind_ip_option} \
                    --oplogSize=100 \
                    --fork \
                    ${extra_options};
    fi

    echo "Polling MongoD in 5 second intervals..."
    while ! "$MONGO" --port "${port}" --eval "db.hostInfo()" > /dev/null 2>&1 ; do echo '.'; sleep 5; done;
    echo "MongoD is running!"
    echo
}
stop_mongodb() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A port was not supplied!"
        echo "Usage: stop_mongodb PORT"
        echo
        exit 1
    fi

    # Check for running mongod-s
    if ! is_local_port_open "$1"; then
        echo "MongoDB is not running; skipping stop!"
        return
    fi

    _set_mongod_vars

    # Start Mongod
    echo "Stopping MongoDB on port $1..."
    "$MONGO" admin --port "$1" --eval "db.shutdownServer()"
    # shellcheck disable=SC2009
    ps -ef | grep "mongod --port $1" | grep -v grep | awk '{ print $2 }' | xargs -r kill -9

    echo "Polling MongoD in 5 second intervals..."
    while "$MONGO" --port "$1" --eval "db.hostInfo()" > /dev/null 2>&1 ; do echo '.'; sleep 5; done;
    echo "MongoD has stopped running!"
}

# #######################################################
#                 INSTALL MMS PACKAGE
# #######################################################
_get_mms_config_file() {
    if [[ "${PLATFORM}" = "windows" ]]; then
       echo "/cygdrive/c/MMSData/Server/Config/conf-mms.properties"
    else
       echo "${DEFAULT_MMS_DIR}/conf/conf-mms.properties"
    fi
}
_get_mms_archive() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "The first parameter should either be a file or an extension!"
        echo "Usage: _get_mms_archive /path/to/file.tar.gz"
        echo "Usage: _get_mms_archive tar.gz"
        echo
        exit 1
    fi

    local ext
    if [ -f "$1" ]; then
        ext="${1##*/}" # get the file's name
        ext="${1#*.}"  # get the file's extension
    else
        ext="$1"
    fi

    echo "ops_manager.${ext}"
}
_release_archive_name() {
    echo "ops_manager_release_archive.$(date +%Y-%m-%d).json"
}
_ensure_release_archive() {
    mkdir -p "$(_user_dir)/ego"
    pushd "$(_user_dir)/ego" > /dev/null
    if [ ! -f "$(_release_archive_name)" ]; then
        _curl "${curl_opts}" -o "$(_release_archive_name)" "https://info-mongodb-com.s3.amazonaws.com/com-download-center/ops_manager_release_archive.json"
    fi
    popd > /dev/null
}
_find_om_archive_by_version() {
    _ensure_release_archive
    
    if [[ "$#" -lt 3 ]]; then
        echo "Usage: _find_om_archive_by_version VERSION ARCH PACKAGE_FORMAT FILE_TYPE"
        echo "e.g.: _find_om_archive_by_version 4.0.0 x86_64 deb deb"
        echo
        exit 1
    fi
    VERSION="$1"
    ARCH="$2"
    PACKAGE_FORMAT="$3"
    FILE_TYPE="$4"
    
    local result
    result=$(jq -r -c '.currentReleases[], .oldReleases[] 
        | select( .version | contains("'"${VERSION}"'")) 
        | .platform[] | select (.arch=="'"${ARCH}"'") 
        | select ( .package_format | contains("'"${PACKAGE_FORMAT}"'")) 
        | .packages.links[] | select(.name=="'"${FILE_TYPE}"'") 
        | .download_link' < "$(_user_dir)/ego/$(_release_archive_name)")
    echo "${result}"
}
_identify_installable_om_archive() {
    local package_format
    if [[ "${PLATFORM}" = "windows" ]]; then
        package_format="msi"

    elif [[ "${PLATFORM}" = "debian" ]] || [[ "${PLATFORM}" = "ubuntu" ]]; then # Debian/Ubuntu
        package_format="deb"

    elif [[ "${PLATFORM}" = "rhel" ]] || [[ "${PLATFORM}" = "amazon" ]] || [[ "${PLATFORM}" = "suse" ]]; then # Red Hat/Amazon Linux/SuSe
        package_format="rpm"
    else
        _unsupported_distro
    fi

    set -vx
    local tgz
    tgz="${package_format}"
    local version
    echo "$*"
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --version) version="$2"; shift 2;;
            --tgz) tgz="tar.gz"; shift;;
            * ) echo "Invalid configuration option: $1" ; exit 1 ;;
        esac
    done

    # Parameter check
    if [[ -z "$version" ]]; then
        echo "A version was not supplied!"
        echo "Usage: _identify_installable_om_archive --version VERSION [--tgz]"
        echo
        exit 1
    fi

    _find_om_archive_by_version "$version" "x86_64" "$package_format" "$tgz"
}
_download_ops_manager() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "The Ops Manager archive was not supplied!"
        echo "Usage: _download_ops_manager OPS_MANAGER_ARCHIVE"
        echo
        exit 1
    fi
    local archive="$1"

    pushd "$(_user_dir)" > /dev/null
    local local_file
    local_file="$(_get_mms_archive "${archive}")"
    echo "Downloading Ops Manager: ${archive} to ${local_file}..."
    _curl "${curl_opts}" -o "${local_file}" "${archive}"
    echo "Downloaded ${archive} to ${local_file}..."
    popd > /dev/null
}
_skip_ops_manager_registration_wizard() {
    echo "Skipping Ops Manager Registration Wizard..."
    echo
    replace_property_in_file "$(_get_mms_config_file)" "mms.ignoreInitialUiSetup" "true"
    replace_property_in_file "$(_get_mms_config_file)" "mms.fromEmailAddr" "noreply@example.com"
    replace_property_in_file "$(_get_mms_config_file)" "mms.replyToEmailAddr" "noreply@example.com"
    replace_property_in_file "$(_get_mms_config_file)" "mms.adminEmailAddr" "noreply@example.com"
    replace_property_in_file "$(_get_mms_config_file)" "mms.mail.transport" "smtp"
    replace_property_in_file "$(_get_mms_config_file)" "mms.mail.hostname" "localhost"
    replace_property_in_file "$(_get_mms_config_file)" "mms.mail.port" "25"
    replace_property_in_file "$(_get_mms_config_file)" "mms.mail.ssl" "false"
}
_configure_ops_manager() {
    _set_mongod_vars

    echo "Configuring Ops Manager..."
    if [[ "${PLATFORM}" = "windows" ]]; then
        replace_property_in_file "$(_get_mms_config_file)" "rootDirectory" "C:\\\\MMSData\\\\BackupData\\\\"

        # Forward the ports if not using default values
        # Solution taken from: https://stackoverflow.com/questions/11525703/port-forwarding-in-windows
        if [[ "${MMS_PORT}" != "8080" ]]; then
            netsh interface portproxy add v4tov4 listenport="${MMS_PORT}" listenaddress=0.0.0.0 connectport=8080 connectaddress="$(aws_get_local_ip)"
        fi
        if [[ "${MMS_SSL_PORT}" != "8443" ]]; then
            netsh interface portproxy add v4tov4 listenport="${MMS_SSL_PORT}" listenaddress=0.0.0.0 connectport=8443 connectaddress="$(aws_get_local_ip)"
        fi

        AUTOMATION_RELEASE_DIR="C:\\MMSData\\MongoDBReleases"

        # Force the automation release dir (expected by E2E tests)
        # NOTE: This value needs to match what is defined by the E2E tests, otherwise the OnPrem Generic E2E tests will fail
        replace_property_in_file "$(_get_mms_config_file)" "automation.versions.directory" "C:\\\\MMSData\\\\MongoDBReleases\\\\"

    else
        # Configure backup head
        mkdir -p /head
        chown mongodb-mms:mongodb-mms /head
        replace_property_in_file "$(_get_mms_config_file)" "rootDirectory" "/head/"

        # Configure ports
        replace_property_in_file "${DEFAULT_MMS_DIR}/conf/mms.conf" "BASE_PORT" "${MMS_PORT}"
        replace_property_in_file "${DEFAULT_MMS_DIR}/conf/mms.conf" "BASE_SSL_PORT" "${MMS_SSL_PORT}"

        # Define and create the release automation dir, if not defined
        AUTOMATION_RELEASE_DIR="/data/automation/mongodb-releases/"
        mkdir -p "${AUTOMATION_RELEASE_DIR}"
        chmod -R 0777 "${AUTOMATION_RELEASE_DIR}"

        # Force the automation release dir (expected by E2E tests)
        # NOTE: This value needs to match what is defined by the E2E tests, otherwise the OnPrem Generic E2E tests will fail
        replace_property_in_file "$(_get_mms_config_file)" "automation.versions.directory" "${AUTOMATION_RELEASE_DIR}"
    fi

    # Extra properties
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --skip-registration-wizard) _skip_ops_manager_registration_wizard; shift;;
            --appdb-url) replace_property_in_file "$(_get_mms_config_file)" "mongo.mongoUri" "$2"; shift 2;;
            --central-url) replace_property_in_file "$(_get_mms_config_file)" "mms.centralUrl" "$2"; shift 2;;
            * ) echo "Invalid configuration option: $1" ; exit 1 ;;
        esac
    done
}
_install_ops_manager() {
    pushd "$(_user_dir)" > /dev/null

    # Determine if this is an upgrade operation
    local upgrade=0
    local archive
    while [[ "$#" -gt 0 ]]; do
      case "$1" in
        --upgrade) upgrade=1; shift ;;
        --archive) archive="$2"; shift 2;;
        * ) echo "Invalid install option: $1" ; exit 1 ;;
      esac
    done

    # specify RPM upgrade options
    declare -a rpm_flags
    rpm_flags[0]="-ivh" # install package by default
    if [[ "$upgrade" -eq 1 ]]; then
        rpm_flags[0]="-Uvh"
        rpm_flags[1]="--oldpackage"
    fi

    local local_file
    local_file="$(_get_mms_archive "${archive}")"
    if [[ ! -f "${local_file}" ]]; then
        echo "Cannot install Ops Manager: ${local_file} does not exist!"
        echo
        exit 1
    fi

    local ext="${local_file#*.}"
    
    if [[ "${ext}" == "tgz" || "${ext}" == "tar.gz" ]]; then
        # Using a tar.gz
        echo "TODO: tar.gz installs are not fully supported yet; aborting for now"
        echo
        exit 1

    elif [[ "${PLATFORM}" = "windows" ]]; then
        if [ "${upgrade}" -eq 1 ]; then
            echo "Upgrading Ops Manager on Windows is not supported"
            echo
            exit 1
        fi
        
        echo "Installing the VS2013 redistributable..."
        echo
        _curl "${curl_opts}" -o vcredist_x64.exe https://download.microsoft.com/download/2/E/6/2E61CFA4-993B-4DD4-91DA-3737CD5CD6E3/vcredist_x64.exe
        chmod +x vcredist_x64.exe
        ./vcredist_x64.exe /quiet /norestart || echo "VC redist 2013 for Ops Manager might already be installed..."
        rm -f vcredist_x64.exe

        echo "Installing Ops Manager (${local_file})..."
        msiexec /passive /i "${local_file}" || echo "Ops Manager might already be installed..."
        rm -f "${local_file}"

    elif [[ "${PLATFORM}" = "debian" ]] || [[ ${PLATFORM} = "ubuntu" ]]; then # Debian/Ubuntu
        echo "Installing Ops Manager (${local_file})..."
        dpkg -i --force-confnew "${local_file}"
        rm -f "${local_file}"

    elif [[ "${PLATFORM}" = "rhel" ]] || [[ ${PLATFORM} = "amazon" ]] || [[ ${PLATFORM} = "suse" ]]; then # Red Hat/Amazon Linux/SuSe
        echo "Installing Ops Manager (${local_file})..."
        rpm "${rpm_flags[@]}" "${local_file}"
        rm -f "${local_file}"
    else
        echo "Unsupported combination of options or something went wrong: $*"
        echo "Exiting!"
        echo
        exit 1
    fi

    popd > /dev/null
}
_find_installed_package() {
    # Parameter check
    if [[ "$#" -eq 0 ]]; then
        echo "A package name was not supplied!"
        echo "Usage: _find_installed_package PACKAGE_NAME"
        echo
        exit 1
    fi

    if [[ "${PLATFORM}" = "windows" ]]; then
        echo "Finding installed packages is not supported on Windows"
        exit 1

    elif [[ "${PLATFORM}" = "debian" ]] || [[ "${PLATFORM}" = "ubuntu" ]]; then # Debian/Ubuntu
        dpkg --get-selections | grep -v "deinstall" | grep "$1" | awk '{print $1}'

    elif [[ "${PLATFORM}" = "rhel" ]] || [[ "${PLATFORM}" = "amazon" ]] || [[ "${PLATFORM}" = "suse" ]]; then # Red Hat/Amazon Linux/SuSe
        rpm -qa | grep "$1"
    fi
}
_uninstall_ops_manager() {
    echo "Uninstalling Ops Manager..."
    INSTALLED_VERSION="$(_find_installed_package mongodb-mms)"
    
    if [[ -z "$INSTALLED_VERSION" ]]; then
        echo "Ops Manager is not present on this host. Skiping uninstall..."
        echo
        return
    fi

    echo "Uninstalling ${INSTALLED_VERSION}..."
    if [[ "${PLATFORM}" = "debian" ]] || [[ ${PLATFORM} = "ubuntu" ]]; then # Debian/Ubuntu
        dpkg -r "${INSTALLED_VERSION}"

    elif [[ "${PLATFORM}" = "rhel" ]] || [[ ${PLATFORM} = "amazon" ]] || [[ ${PLATFORM} = "suse" ]]; then # Red Hat/Amazon Linux/SuSe
        rpm -e "${INSTALLED_VERSION}"

    else
        echo "Uninstalling (${INSTALLED_VERSION}) is not supported on Windows..."
        echo
    fi
}

# #######################################################
#                    START OPS MANAGER
# #######################################################
_is_running_ssl() {
    if grep -q "mms.https.PEMKeyFile" "$(_get_mms_config_file)" > /dev/null 2>&1; then
        return 0
    fi
    return 1
}
get_om_port() {
    if _is_running_ssl; then
        echo ${MMS_SSL_PORT}
    else
        echo ${MMS_PORT}
    fi
}
get_om_scheme() {
    if _is_running_ssl; then
        echo "https"
    else
        echo "http"
    fi
}
#shellcheck disable=SC2120
start_ops_manager() {
    local port
    port="$(get_om_port)"

    local do_not_wait_for_port=0
    local do_not_wait_for_daemon=0
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --skip-waiting-for-service-start) do_not_wait_for_port=1 ; shift ;;
            --skip-waiting-for-daemon) do_not_wait_for_daemon=1 ; shift ;;
            * ) echo "Invalid start option: $1" ; exit 1 ;;
        esac
    done

    if [[ "${PLATFORM}" = "windows" ]]; then # Windows
        # On Windows we start on the default port and forward MMS_PORT to it
        # for this check, we need to verify the standard port
        port=8080
    fi

    if is_local_port_open "${port}"; then
        echo "Found previously running Ops Manager service; skipping start."
        echo
        return
    fi

    echo "Starting the Ops Manager and Backup Daemon services..."
    if [[ "${PLATFORM}" = "windows" ]]; then # Windows
        net start "MongoDB Ops Manager HTTP Service"

        if [[ "${do_not_wait_for_port}" -eq 0 ]]; then
            echo "Waiting for Ops Manager to start..."
            wait_for_open_local_port "${port}"
            echo "Ops Manager is running."
        fi

        net start "MongoDB Backup Daemon Service"

        if [[ "${do_not_wait_for_daemon}" -eq 0 ]]; then
            echo "Waiting for the Backup Daemon to start..."
            wait_for_open_local_port "${MMS_DAEMON_PORT}"
            echo "The Backup Daemon is running."
        fi

    else # Standard Linux
        service_command start mongodb-mms

        if [[ "${do_not_wait_for_port}" -eq 0 ]]; then
            echo "Waiting for Ops Manager to start..."
            wait_for_open_local_port "${port}"
            echo "Ops Manager is running."
        fi

        if [[ "${do_not_wait_for_daemon}" -eq 0 ]]; then
            echo "Waiting for the Backup Daemon to start..."
            wait_for_open_local_port "${MMS_DAEMON_PORT}"
            echo "The Backup Daemon is running."
        fi
    fi
}
stop_ops_manager() {
    local port
    port="$(get_om_port)"

    echo "Stopping Ops Manager..."

    if [[ "${PLATFORM}" = "windows" ]]; then # Windows
        # On Windows we start on the default port and forward MMS_PORT to it
        # use the default port for checks
        port=8080
    fi

    if ! is_local_port_open "${port}"; then
        echo "Ops Manager is not running; skipping stop."
        echo
        return
    fi

    echo "Stopping the Ops Manager service..."
    set +e  # do not fail here
    if [[ "${PLATFORM}" = "windows" ]]; then # Windows
        net stop "MongoDB Backup Daemon Service"
        net stop "MongoDB Ops Manager HTTP Service"

    else # Standard Linux
        service_command stop mongodb-mms
    fi
    set -e

    echo "Waiting for Ops Manager to stop..."
    wait_for_closed_local_port "${port}"
    echo "Ops Manager has stopped!"
}
restart_ops_manager() {
    stop_ops_manager || echo "Stopped..."
    start_ops_manager
}

# #######################################################
#                   IPTABLES DEFINITIONS
# #######################################################
_iptables_allow_localhost() {
    iptables -A INPUT  --in-interface  lo --jump ACCEPT
    iptables -A OUTPUT --out-interface lo --jump ACCEPT
}
_iptables_allow_http_mms_ports() {
    # MMS ports
    if _is_running_ssl; then
        iptables -A INPUT  --proto tcp --dport "${MMS_SSL_PORT}" --jump ACCEPT
        iptables -A OUTPUT --proto tcp --sport "${MMS_SSL_PORT}" --jump ACCEPT
    else
        iptables -A INPUT  --proto tcp --dport "${MMS_PORT}"     --jump ACCEPT
        iptables -A OUTPUT --proto tcp --sport "${MMS_PORT}"     --jump ACCEPT
    fi
}
_iptables_allow_dns() {
    # Allow DNS traffic
    iptables -A INPUT  --proto udp --sport 53 --jump ACCEPT
    iptables -A OUTPUT --proto udp --dport 53 --jump ACCEPT
    iptables -A INPUT  --proto tcp --sport 53 --jump ACCEPT
    iptables -A OUTPUT --proto tcp --dport 53 --jump ACCEPT
}
_iptables_allow_ssh() {
    # Allow SSH traffic
    iptables -A INPUT  --proto tcp --dport 22 --jump ACCEPT
    iptables -A OUTPUT --proto tcp --sport 22 --jump ACCEPT
}
_iptables_allow_subnet() {
    # Allow access over AWS's private IP net
    iptables -A INPUT  --dest "$(get_host_ip)/16" --jump ACCEPT
    iptables -A OUTPUT --dest "$(get_host_ip)/16" --jump ACCEPT
}
_iptables_allow_aws_meta() {
    # Allow AWS's metadata endpoint
    _iptables_allow_host 169.254.169.254
}
_iptables_deny_all() {
    # Always allow established connections
    iptables -A INPUT  --match state --state ESTABLISHED,RELATED --jump ACCEPT
    iptables -A OUTPUT --match state --state ESTABLISHED,RELATED --jump ACCEPT

    # Drop everything else
    iptables -A INPUT  -p udp -j REJECT --reject-with icmp-port-unreachable
    iptables -A OUTPUT -p udp -j REJECT --reject-with icmp-port-unreachable
    iptables -A INPUT  -p tcp -j REJECT --reject-with tcp-reset
    iptables -A OUTPUT -p tcp -j REJECT --reject-with tcp-reset
}
_iptables_allow_all() {
    # Reset the access policies to prevent getting locked out
    iptables --policy INPUT   ACCEPT
    iptables --policy OUTPUT  ACCEPT
    iptables --policy FORWARD ACCEPT
    iptables --zero
    iptables --flush
}
_iptables_allow_host() {
    # Allow access to/from the specified host
    iptables -I INPUT  1 --dest "$1/32" --jump ACCEPT
    iptables -I OUTPUT 2 --dest "$1/32" --jump ACCEPT
}
_iptables_allow_outgoing_for_user() {
    # Allow HTTP/S traffic for a given user
    iptables -I OUTPUT 1 --proto tcp --dport  80 --match state --match owner --uid-owner "$1" --state NEW,ESTABLISHED --jump ACCEPT
    iptables -I OUTPUT 2 --proto tcp --dport 443 --match state --match owner --uid-owner "$1" --state NEW,ESTABLISHED --jump ACCEPT
}
_iptables_show() {
    # Show current iptables rules
    echo
    echo "Current iptables rules:"
    echo
    iptables -L
    echo
}
# shellcheck disable=SC2120
network_access_restrict() {
    if [[ "${PLATFORM}" = "windows" ]]; then
        echo "Cannot use iptables in Cygwin..."
        return
    fi

    echo "Restricting outgoing network access to all users but root, and the system proxy user."
    echo "Note: To completely disallow network access, call 'network_access_restrict --strict'"
    echo

    # Restore to defaults
    _iptables_allow_all

    # Allow network access for a few system users, unless '--strict` was specified
    if [[ "$#" -ne 1 || $1 != "--strict" ]]; then
        _iptables_allow_outgoing_for_user root

        # Allow potential proxy users outgoing access
        if getent passwd proxy > /dev/null; then
            _iptables_allow_outgoing_for_user proxy
        fi
        if getent passwd squid > /dev/null; then
            _iptables_allow_outgoing_for_user squid
        fi
    fi

    # Configure access policies
    _iptables_allow_localhost
    _iptables_allow_ssh
    _iptables_allow_http_mms_ports
    _iptables_allow_dns
    _iptables_allow_aws_meta
    _iptables_allow_subnet
    _iptables_allow_host "$(aws_get_public_ip)"
    _iptables_deny_all
    _iptables_show
}
network_access_open() {
    if [[ "${PLATFORM}" = "windows" ]]; then
        echo "Cannot use iptables in Cygwin..."
        return
    fi

    # Allow internet traffic to all hosts
    echo "Allowing outgoing network access"
    echo

    _iptables_allow_all
    _iptables_show
}


# #######################################################
#             INSTALL THE SQUID PROXY SERVER
# #######################################################
configure_proxy() {
    if [[ "${PLATFORM}" = "windows" ]]; then
        echo "Cannot set up Squid in Cygwin!"
        return

    elif [[ -z "$(_find_installed_package squid)" ]]; then
        echo "Squid is not installed on this system! Skipping Proxy configuration..."
        echo
        return
    fi

    echo "# Ops Manager proxy config"                | tee    /etc/squid/squid.conf
    if [[ "${PLATFORM}" = "rhel" && ${OSVER} = 6 ]] || [[ ${PLATFORM} = "debian" && ${OSVER} = 7 ]]; then
        echo ""                                      | tee -a /etc/squid/squid.conf
        echo "# Define ACLs in older Squid versions" | tee -a /etc/squid/squid.conf
        echo "acl localhost src 127.0.0.1/32"        | tee -a /etc/squid/squid.conf
        echo "acl manager proto cache_object"        | tee -a /etc/squid/squid.conf
        echo "acl all src 0.0.0.0/0.0.0.0"           | tee -a /etc/squid/squid.conf
    fi
    echo ""                                          | tee -a /etc/squid/squid.conf
    echo "# Squid settings"                          | tee -a /etc/squid/squid.conf
    echo "http_port ${PROXY_PORT}"                   | tee -a /etc/squid/squid.conf
    echo "cache deny all"                            | tee -a /etc/squid/squid.conf
    echo ""                                          | tee -a /etc/squid/squid.conf
    echo "# Allow localhost"                         | tee -a /etc/squid/squid.conf
    echo "http_access allow localhost"               | tee -a /etc/squid/squid.conf
    echo ""                                          | tee -a /etc/squid/squid.conf
    echo "# Allow local subnet"                      | tee -a /etc/squid/squid.conf
    echo "acl localnet src $(get_host_ip)/16"        | tee -a /etc/squid/squid.conf
    echo "http_access allow localnet"                | tee -a /etc/squid/squid.conf
    echo ""                                          | tee -a /etc/squid/squid.conf
    echo "# Deny everything else"                    | tee -a /etc/squid/squid.conf
    echo "http_access deny manager"                  | tee -a /etc/squid/squid.conf
    echo "http_access deny all"                      | tee -a /etc/squid/squid.conf
    echo ""                                          | tee -a /etc/squid/squid.conf

    echo "Restarting squid..."
    service_command restart squid
    
    echo "Waiting for squid to start..."
    wait_for_open_local_port "${PROXY_PORT}"
}


# #######################################################
#                           SSL
# #######################################################
ssl_generate_server_certificate() {
    if [[ "$#" -eq 0 || -z "$1" ]]; then
        ssl_hostname="$(aws_get_public_ip)"
        echo "A hostname was not specified; defaulting to: ${ssl_hostname}"
        echo
    else
        ssl_hostname="$1"
    fi

    if [[ "${PLATFORM}" = "windows" ]]; then # Windows
        echo "Configuring SSL on Windows is not supported!"
        echo
        exit 1
    fi

    if [ -f "/etc/ssl/${ssl_hostname}.pem" ]; then
        echo "A certificate for ${ssl_hostname} was already generated; will not regenerate..."
        echo
        return
    fi

    echo "Generating root and ssl certs for ${ssl_hostname}"
    echo

    # CREATE A ROOT CA
    pushd "$(_user_dir)" > /dev/null
    openssl genrsa -out rootCA.key 2048
    openssl req -x509 -new -nodes -key rootCA.key -days 365 -out rootCA.crt -subj "/C=IE/ST=D/L=Dublin/O=DO NOT TRUST/OU=DO NOT TRUST/CN=DO NOT TRUST"
    cat rootCA.crt rootCA.key > rootCA.pem

    # Create the Certificate for the Ops Manager Server
    echo keyUsage=critical, digitalSignature, keyEncipherment > serverCertOpts
    echo extendedKeyUsage = serverAuth > serverCertOpts
    openssl genrsa -out "${ssl_hostname}.key" 2048
    openssl req -new -key "${ssl_hostname}.key" -out "${ssl_hostname}.csr" -subj "/C=IE/ST=D/L=Dublin/O=DO NOT TRUST/OU=DO NOT TRUST SERVER/CN=${ssl_hostname}"
    openssl x509 -req -in "${ssl_hostname}.csr" -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out "${ssl_hostname}.crt" -days 365 -extfile serverCertOpts
    cat "${ssl_hostname}.crt" "${ssl_hostname}.key" > "${ssl_hostname}.pem"

    # Print root CA info, as it will be needed to connect to the OM host from another machine
    echo "Root Certificate authority"
    echo "--------------------------"
    cat  rootCA.pem
    echo "--------------------------"
    echo

    # Deploy certificates to system dir
    # shellcheck disable=SC2086
    mv ${ssl_hostname}.* rootCA.* /etc/ssl/
    echo "SSL certificate deployed at:      /etc/ssl/${ssl_hostname}.pem"
    echo "ROOT CA certificate deployed at:  /etc/ssl/rootCA.pem"
    echo
    popd > /dev/null
}
ops_manager_configure_ssl() {
    if [[ "$#" -eq 0 || -z "$1" ]]; then
        ssl_hostname="$(aws_get_public_ip)"
        echo "A hostname was not specified; defaulting to: ${ssl_hostname}"
        echo
    else
        ssl_hostname="$1"
    fi

    if [[ "${PLATFORM}" = "windows" ]]; then # Windows
        echo "Configuring SSL on Windows is not supported!"
        echo
        exit 1
    fi

    local pem_file
    pem_file="/etc/ssl/${ssl_hostname}.pem"
    if [ ! -f "${pem_file}" ]; then
        echo "Could not find SSL certificate at: ${pem_file}; stopping"
        echo
        exit 1
    fi

    (
        echo ""
        echo "# SSL settings"
        echo "mms.centralUrl=https://${ssl_hostname}:${MMS_SSL_PORT}"
        echo "mms.https.PEMKeyFile=${pem_file}"
        if [ -f /etc/ssl/rootCA.pem ]; then
            echo "mms.https.CAFile=/etc/ssl/rootCA.pem"
        fi
        echo ""
    ) | tee -a "$(_get_mms_config_file)"
}


# #######################################################
#                 MAIN Ops Manager actions
# #######################################################
ops_manager_uninstall() {
    echo "Stopping and uninstalling the Ops Manager service..."
    stop_ops_manager
    _uninstall_ops_manager
}
ops_manager_clean() {
    echo "Stopping Ops Manager, the AppDB, and the Blockstore; also deleting data dirs..."
    echo

    ops_manager_uninstall

    echo "Stopping the Ops Manager AppDB..."
    stop_mongodb "${DEFAULT_MMS_MONGODB_PORT}"

    echo "Stopping the Ops Manager blockstore..."
    stop_mongodb "${DEFAULT_MMS_BLOCKSTORE_MONGODB_PORT}"

    echo "Uninstalling MongoDB..."
    _uninstall_mongodb

    DBPATH="$(_user_dir)/${MONGOD_INSTALL_DIR}"
    echo "Removing all data from ${DBPATH}..."
    rm -rf "${DBPATH:?}"/*

    echo "The Ops Manager environment was reset."
    echo
}
ops_manager_install_version() {
    _usage() {
        echo
        echo 'Options:'
        echo '  --version <version>           The Ops Manager version to install'
        echo '  --tgz                         Use a tar.gz instead of a pre-packaged binary'
        echo '  --mongodb-version <version>   The MongoDB version to use for AppDB'
        echo '  --central-url <uri>           Ops Manager central url'
        echo '  --ssl                         Generate and deploy an SSL certificate and configure Ops Manager to use it'
    }
    
    local version
    local mongodb_version
    local central_url
    local ssl_hostname
    local tgz
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --version) version="${2-}"; shift 2 ;;
            --mongodb-version) mongodb_version="${2-}"; shift 2 ;;
            --central-url) central_url="${2-}"; shift 2 ;;
            --ssl) ssl_hostname="${2-}"; shift 2 ;;
            --tgz) tgz="--tgz"; shift ;;
            * ) echo "Invalid configuration option: $1"; return 1 ;;
        esac
    done

    # Parameter check
    if [[ -z "${version}" ]]; then
        echo "A version was not specified!"
        _usage
        exit 1
    fi

    echo "Installing Ops Manager version: ${version}"

    _iptables_allow_all
    _ensure_tmp_dir_is_writeable

    local archive
    archive="$(_identify_installable_om_archive --version "$version" "$tgz")"

    ops_manager_install_from_link --archive "$archive" \
                                  --mongodb-version "$mongodb_version" \
                                  --central-url "$central_url" \
                                  --ssl "$ssl_hostname"
}
ops_manager_install_from_link() {
    _usage() {
        echo
        echo 'Options:'
        echo '  --archive <archive>           The Ops Manager archive to download and install'
        echo '  --mongodb-version <version>   The MongoDB version to use for AppDB'
        echo '  --central-url <uri>           Ops Manager central url'
        echo '  --ssl                         Generate and deploy an SSL certificate and configure Ops Manager to use it'
    }

    local archive=
    local mongodb_version
    local central_url="http://localhost:${MMS_PORT}"
    local appdb_url="mongodb://localhost:${DEFAULT_MMS_MONGODB_PORT}"
    local ssl=0
    local ssl_hostname
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --archive) archive="${2-}"; shift 2 ;;
            --mongodb-version) mongodb_version="${2-}"; shift 2 ;;
            --central-url) central_url="${2-}"; shift 2 ;;
            --ssl) ssl=1; ssl_hostname="${2-}"; shift 2 ;;
            * ) echo "Invalid configuration option: $1"; return 1 ;;
        esac
    done

    # Parameter check
    if [[ -z "${archive}" ]]; then
        echo "Archive was not specified!"
        _usage
        exit 1
    fi

    _iptables_allow_all
    resolve_system_dependencies

    local upgrade
    INSTALLED_VERSION="$(_find_installed_package mongodb-mms)"
    if [[ -n "$INSTALLED_VERSION" ]]; then
        # Found a previously installed version
        upgrade="--upgrade"
    fi

    if [[ "$upgrade" == "--upgrade" ]]; then
        echo "Installing and starting the AppDB and Blockstore"
        echo

        download_mongodb "${mongodb_version}"

        if ! is_local_port_open "${DEFAULT_MMS_MONGODB_PORT}"; then
            start_mongodb "${DEFAULT_MMS_MONGODB_PORT}"
        fi

        if ! is_local_port_open "${DEFAULT_MMS_BLOCKSTORE_MONGODB_PORT}"; then
            start_mongodb "${DEFAULT_MMS_BLOCKSTORE_MONGODB_PORT}"
        fi
    fi

    _download_ops_manager "$archive"
    
    if [[ "$upgrade" == "--upgrade" ]]; then
        # Stop Ops Manager before performing an upgrade
        stop_ops_manager
    fi

    _install_ops_manager --archive "$archive" "$upgrade"

    _configure_ops_manager --skip-registration-wizard \
                          --central-url "${central_url}" \
                          --appdb-url "${appdb_url}"

     # Configure SSL
    if [[ "${ssl}" -eq 1 && -n "${ssl_hostname}" ]]; then
        echo "Configuring Ops Manager with SSL for host ${ssl_hostname}..."
        ssl_generate_server_certificate "${ssl_hostname}"
        ops_manager_configure_ssl "${ssl_hostname}"
    fi

    # Start the service
    start_ops_manager
}

# TODO: continue reviewing from here
# TODO: merge into previous method
ops_manager_start_from_tgz() {
    if [[ "$#" -lt 2 ]]; then
        echo "Invalid call: 'ops_manager_start_from_tgz $*'"
        echo "Usage: ops_manager_start_from_tgz TGZ_LINK BASE_HOST BASE_PORT"
        echo "- TGZ_LINK: location of the Ops Manager package to be installed on the current machine"
        echo "- BASE_HOST: Host on which the Ops Manager install will be started"
        echo
        return 1
    fi

    # TODO: _download_ops_manager --version "${version}" --tgz
    # Determine args
    TGZ_LINK="$1"
    BASE_HOST="$2"

    # Variables
    TARGET_DIR="${DIR}/mongodb-mms"
    TARGET_TGZ="${TARGET_DIR}/mms.tgz"
    ENC_KEY_PATH="${TARGET_DIR}/etc/mongodb-mms/gen.key"

    # TODO: --config-flags
    download_mongodb "${CONFIGDB_MDB_VERSION}"
    if ! is_local_port_open "${DEFAULT_MMS_MONGODB_PORT}"; then
        start_mongodb "${DEFAULT_MMS_MONGODB_PORT}"
    fi
    if ! is_local_port_open "${DEFAULT_MMS_BLOCKSTORE_MONGODB_PORT}"; then
        start_mongodb "${DEFAULT_MMS_BLOCKSTORE_MONGODB_PORT}"
    fi

    # Use the link provided (needed for builds)
    echo "Downloading Ops Manager: ${TGZ_LINK} to ${TARGET_TGZ}..."
    _curl "${curl_opts}" -o "${TARGET_TGZ}" "${TGZ_LINK}"

    echo "Extracting tgz: ${TARGET_TGZ} to ${TARGET_DIR}..."
    tar -xzf "${TARGET_TGZ}" -C "${TARGET_DIR}" --strip-components 1

    echo "Generating a new Enc Key: ${ENC_KEY_PATH}..."
    "${TARGET_DIR}"/bin/mms-gen-key -f "${ENC_KEY_PATH}" -o

    echo "Creating automation directories..."
    # Define and create the release automation dir, if not defined
    AUTOMATION_RELEASE_DIR="${TARGET_DIR}/mongodb-releases"
    mkdir -p "${AUTOMATION_RELEASE_DIR}"

    echo "Updating conf to enable remote testing..."
    # Note: This is most of the functionality from _configure_ops_manager and _skip_ops_manager_registration_wizard
    # but we need to run without sudo, so moving it to here.
    replace_property_in_file "${TARGET_DIR}"/conf/mms.conf "BASE_PORT" "${MMS_PORT}"
    replace_property_in_file "${TARGET_DIR}"/conf/mms.conf "BASE_SSL_PORT" "${MMS_SSL_PORT}"
    replace_property_in_file "${TARGET_DIR}"/conf/conf-mms.properties "mms.centralUrl" "http://$BASE_HOST:${MMS_PORT}"
    replace_property_in_file "${TARGET_DIR}"/conf/conf-mms.properties "automation.versions.directory" "${AUTOMATION_RELEASE_DIR}"
    # TODO: call OM config
    replace_property_in_file "${TARGET_DIR}"/conf/conf-mms.properties "mms.ignoreInitialUiSetup" "true"
    replace_property_in_file "${TARGET_DIR}"/conf/conf-mms.properties "mms.fromEmailAddr" "noreply@example.com"
    replace_property_in_file "${TARGET_DIR}"/conf/conf-mms.properties "mms.replyToEmailAddr" "noreply@example.com"
    replace_property_in_file "${TARGET_DIR}"/conf/conf-mms.properties "mms.adminEmailAddr" "noreply@example.com"
    replace_property_in_file "${TARGET_DIR}"/conf/conf-mms.properties "mms.mail.transport" "smtp"
    replace_property_in_file "${TARGET_DIR}"/conf/conf-mms.properties "mms.mail.hostname" "localhost"
    replace_property_in_file "${TARGET_DIR}"/conf/conf-mms.properties "mms.mail.port" "25"
    replace_property_in_file "${TARGET_DIR}"/conf/conf-mms.properties "mms.mail.ssl" "false"

    echo "Starting Ops Manager as current user: $USER..."
    "${TARGET_DIR}"/bin/start-mongodb-mms --enc-key-path "${ENC_KEY_PATH}"
}

# #######################################################
#             SEED THE TARGET ENVIRONMENT
# #######################################################
run() {
    # Print usage info
    if [[ "$#" -lt 2 ]]; then
        echo "Usage: run user@hostname [args...]"
        echo
        exit 1
    fi

    # Determine args
    host=$1
    shift
    args=$*

    echo "Running remote command '${args}' on ${host}..."

    # shellcheck disable=SC2086
    "$SSH" -tt -A "${ssh_opts[@]}" ${SSH_OPTS-} "${host}" $args
}
nohup() {
    # Print usage info
    if [[ "$#" -lt 2 ]]; then
        echo "Usage: nohup user@hostname [args...]"
        echo
        exit 1
    fi

    # Determine args
    host=$1
    shift
    args=$*

    echo "Running remote command (nohup) '${args}' on ${host}..."

    DT="$(date +%Y%m%d%H%M%S)"
    echo "Renaming artifacts generated in previous runs (*.$DT)"
    # shellcheck disable=SC2086
    "$SSH" -tt "${ssh_opts[@]}" ${SSH_OPTS-} "${host}" "if [ -e ${NOHUP_PROV_FILE}.out ]; then mv ${NOHUP_PROV_FILE}.out ${NOHUP_PROV_FILE}.out.$DT; fi; \
        if [ -e ${NOHUP_PROV_FILE} ]; then mv ${NOHUP_PROV_FILE} ${NOHUP_PROV_FILE}.$DT; fi"

    # Create a provisioning script, then upload it to the host
    PROV=$(mktemp)
    echo "#!/usr/bin/env bash" > "$PROV" # Create a new file
    chmod 0775 "$PROV"                   # Allow a+rx
    # shellcheck disable=SC2129
    echo "echo \"Started at: \$(date)\"" >> "$PROV" # Print start date
    echo "$args" >> "$PROV"              # Run command
    echo "exit_code=\$?" >> "$PROV"      # Capture exit code
    echo "printf \$exit_code >> ${NOHUP_PROV_FILE}.out" >> "$PROV" # Save exit code
    echo "echo \"Finished at: \$(date)\"" >> "$PROV" # Print completion date
    echo "echo \"Exit code: \$exit_code\"" >> "$PROV" # And output the exit code

    echo "Uploading provisioning script to ${host}:${NOHUP_PROV_FILE}..."
    # shellcheck disable=SC2016,SC2086
    "$SCP" "${ssh_opts[@]}" ${SSH_OPTS-} "${PROV}" "${host}:${NOHUP_PROV_FILE}"

    echo "Executing provisioning script..."
    # shellcheck disable=SC2086
    "$SSH" -tt "${ssh_opts[@]}" ${SSH_OPTS-} "${host}" nohup bash -c './'${NOHUP_PROV_FILE}' > '${NOHUP_LOG_FILE}' 2>&1' &
    echo "Remote command (nohup) was executed on ${host}..."
    echo "${args}"
    echo
}
tail() {
    # Print usage info
    if [[ "$#" -lt 1 ]]; then
        echo "Usage: tail user@hostname"
        echo
        exit 1
    fi

    # Determine args
    host=$1

    echo "Tailing ${NOHUP_LOG_FILE} from ${host}..."
    # shellcheck disable=SC2086
    "$SSH" -tt "${ssh_opts[@]}" ${SSH_OPTS-} "${host}" "while [ ! -e \"${NOHUP_LOG_FILE}\" ]; do sleep 1; done; tail -n 500 -F \"${NOHUP_LOG_FILE}\" | while IFS= read line; do echo \$line; [ -e \"${NOHUP_PROV_FILE}.out\" ] && pkill tail; done"
    echo "Stopped tailing ${NOHUP_LOG_FILE} on ${host}..."
}
scp() {
    # Print usage info
    if [[ "$#" -lt 2 ]]; then
        echo "Usage: scp <source> <destination>"
        echo
        exit 1
    fi

    # shellcheck disable=SC2016,SC2086
    if ! "$SCP" "${ssh_opts[@]}" ${SSH_OPTS-} "$1" "$2"; then
        # Retry once, with increased verbosity
        # shellcheck disable=SC2016,SC2086
        "$SCP" -vvv "${ssh_opts[@]}" ${SSH_OPTS-} "$1" "$2"
    fi
}

seed() {
    # Print usage info
    if [[ "$#" -lt 1 ]]; then
        echo "Usage: seed user@hostname"
        echo
        exit 1
    fi

    echo "Deploying ${SCRIPT} to $1..."
    scp "${DIR}/${SCRIPT}" "$1:"

    # shellcheck disable=SC2016
    exec_cmd='mkdir -p $HOME/bin; mv '${SCRIPT}' $HOME/bin/; $HOME/bin/'${SCRIPT}' link'

    # shellcheck disable=SC2016,SC2086
    if ! "$SSH" -tt "${ssh_opts[@]}" ${SSH_OPTS-} "$1" ${exec_cmd}; then
        # Retry once, with increased verbosity

        # shellcheck disable=SC2016,SC2086
        "$SSH" -vvv -tt "${ssh_opts[@]}" ${SSH_OPTS-} "$1" ${exec_cmd}
    fi
    echo "Deployed ${SCRIPT} to $1..."
}

ssh() {
    # Parameter check
    if [[ "$#" -lt 1 ]]; then
        echo "Invalid call 'ssh $*'"
        echo "Usage: ssh user@hostname"
        echo
        exit 1
    fi

    # Connects to remote host
    echo "Connecting to $1..."
    # shellcheck disable=SC2086
    if ! "$SSH" -tt -A "${ssh_opts[@]}" ${SSH_OPTS-} "$1" /bin/bash; then
        # Retry once, with increased verbosity
        "$SSH" -vvv -tt -A "${ssh_opts[@]}" ${SSH_OPTS-} "$1" /bin/bash
    fi
}


# #######################################################
#                           MAIN
# #######################################################
_available_functions() {
    declare -F | awk '{print $3}' | grep -vE '^_'
}
_usage() {
    echo "Usage: ${0} FUNCTION"
    echo
    echo "Available functions:"
    echo "------------------"
    for func in $(_available_functions); do echo "$func"; done
    echo "------------------"
    echo
    exit 1
}

main() {
    # If no parameters were specified, print the usage help
    if [[ "$#" -eq 0 ]]; then
        _usage
    fi

    # Run as super user, unless the functions do not require it, or the script is run without any parameters
    _determine_architecture
    if [[ ${NON_ROOT_FUNCTIONS} != *"$1"* ]]; then
        [[ "$UID" -eq 0 || "${PLATFORM}" = "windows" ]] || exec sudo -SE "$0" "$@"
    fi

    # Limit the scope of this script to functions defined in it
    #if ! grep -qE "\\b$1\\b" <<< "${AVAILABLE_FUNCTIONS}"; then
    if ! grep -qE "\\b$1\\b" <<< "$(_available_functions)"; then
        echo "Function not defined: '$1'!"
        echo

        # Attempt to match the passed name to the list of available functions
        if [[ $(_available_functions) = *"$1"* ]]; then
            echo "Did you mean?"
            echo "------------------"
            for func in $(_available_functions); do
                if [[ "${func/$1}" != "${func}" ]] ; then
                    echo "${func}"
                fi
            done
            echo "------------------"
            echo
            exit 1

        # Otherwise print the whole list
        else
            _usage
        fi
    fi

    # Set a TERM var if not already in the env
    _fix_term

    "$@"
}

main "$@"